// MIT License

// Copyright (c) 2025 Zherebtsov Nikita <nikita@crimsongold.ru>

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/crimsongoldteam/md_design

#Область ПрограммныйИнтерфейс

Функция ЭтоМассив(Значение) Экспорт
	Возврат ТипЗнч(Значение) = Тип("Массив");
КонецФункции

&НаКлиенте
Функция СоздатьОписаниеТипов(Тип = Неопределено) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("ДлинаСтроки", 0);
	Результат.Вставить("ЧастиДаты", Неопределено);
	Результат.Вставить("ДлинаЧисла", 0);
	Результат.Вставить("ТочностьЧисла", 0);
	Результат.Вставить("Типы", Новый Массив);
	Если Тип <> Неопределено Тогда
		Результат.Типы.Добавить(Тип);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Функция ПреобразоватьПуть(Знач ПутьКПапкеСФайлами, ЭтоLinux) Экспорт
	
	ПутьКПапкеСФайлами = СокрЛП(ПутьКПапкеСФайлами);
	Если ЭтоLinux Тогда
		ПутьКПапкеСФайлами = СтрЗаменить(ПутьКПапкеСФайлами, "\", "/");
	Иначе
		ПутьКПапкеСФайлами = СтрЗаменить(ПутьКПапкеСФайлами, "/", "\");
	КонецЕсли;
	
	СимволРазделитель = 2;
	ПервыеДваСимвола = Лев(ПутьКПапкеСФайлами, СимволРазделитель);
	ВтораяЧасть = Сред(ПутьКПапкеСФайлами, СимволРазделитель + 1);
	Пока СтрНайти(ВтораяЧасть, "\\") > 0 Цикл
		ВтораяЧасть = СтрЗаменить(ВтораяЧасть, "\\", "\");
	КонецЦикла;
	Пока СтрНайти(ВтораяЧасть, "//") > 0 Цикл
		ВтораяЧасть = СтрЗаменить(ВтораяЧасть, "//", "/");
	КонецЦикла;
	
	Возврат ПервыеДваСимвола + ВтораяЧасть;
КонецФункции

&НаКлиенте
Функция ФайлСуществует(ИмяФайла) Экспорт

	ПроверкаФайла = Новый Файл(ИмяФайла);
	Если Не ПроверкаФайла.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ПроверкаФайла.ЭтоФайл() Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
	
КонецФункции 

// Форматирует значение по описанию типа (число, дата и др.).
// 
// Параметры:
//  Значение - Произвольный - Значение для форматирования
//  ОписаниеТипов - Структура - Описание типа значения
// 
// Возвращаемое значение:
// Строка - Отформатированное значение
&НаКлиенте
Функция ФорматироватьЗначениеПоля(Значение, ОписаниеТипов) Экспорт 
	ТипЗначения = ТипЗнч(Значение); 
	Если ТипЗначения = Тип("Число") Тогда
		Возврат ФорматироватьЗначениеЧисло(Значение, ОписаниеТипов);
	КонецЕсли;

	Если ТипЗначения = Тип("Дата") Тогда
		Возврат ФорматироватьЗначениеДата(Значение, ОписаниеТипов);
	КонецЕсли;

	Возврат Значение; 
КонецФункции

// Вычисляет расстояние Левенштейна между двумя строками. 
// Расстояние Левенштейна - это минимальное количество операций вставки, удаления и замены символов, необходимых для преобразования одной строки в другую.
// Решение взято из https://infostart.ru/1c/articles/22461/#message369426
// 
// Параметры:
//  Строка1 - Строка - Первая строка для сравнения
//  Строка2 - Строка - Вторая строка для сравнения
// 
// Возвращаемое значение:
// Число - Расстояние Левенштейна между строками (количество минимальных операций для преобразования)
&НаКлиенте
Функция РасстояниеЛевенштейна(Строка1, Строка2) Экспорт

    ДлинаСтроки1 = СтрДлина(Строка1);
    ДлинаСтроки2 = СтрДлина(Строка2);

    Если ДлинаСтроки1 = 0 Тогда
        Возврат ДлинаСтроки2;
    КонецЕсли;

    Если ДлинаСтроки2 = 0 Тогда
        Возврат ДлинаСтроки1;
    КонецЕсли;

    Матрица = Новый Массив(ДлинаСтроки1 + 1, ДлинаСтроки2 + 1);

    Для Индекс = 0 По ДлинаСтроки1 Цикл
        Матрица[Индекс][0] = Индекс;
    КонецЦикла;

    Для Индекс = 0 По ДлинаСтроки2 Цикл
        Матрица[0][Индекс] = Индекс;
    КонецЦикла;

    Для Индекс1 = 1 По ДлинаСтроки1 Цикл

        СимволСтроки1 = Сред(Строка1, Индекс1, 1);

        Для Индекс2 = 1 По ДлинаСтроки2 Цикл

            СимволСтроки2 = Сред(Строка2, Индекс2, 1);

            Если СимволСтроки1 = СимволСтроки2 Тогда
                Стоимость = 0;
            Иначе
                Стоимость = 1;
            КонецЕсли;

            Матрица[Индекс1][Индекс2] = 
				Мин(Матрица[Индекс1 - 1][Индекс2] + 1, 
					Матрица[Индекс1][Индекс2 - 1] + 1, 
					Матрица[Индекс1 - 1][Индекс2 - 1] + Стоимость);

        КонецЦикла;

    КонецЦикла;

    Возврат Матрица[ДлинаСтроки1][ДлинаСтроки2];

КонецФункции

// Формирует строковое представление операции с учетом её названия и параметров.
// 
// Параметры:
//  Название        - Строка - Название операции
//  МассивПараметры - Массив - Массив параметров операции
// 
// Возвращаемое значение:
// Строка - Строковое представление операции с параметрами
&НаКлиенте
Функция ПолучитьПредставлениеОперации(Название, МассивПараметры) Экспорт

	Результат = Название;
	Если МассивПараметры.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	Возврат Результат + "(" + СтрСоединить(МассивПараметры,", ") + ")";

КонецФункции

// Функция возвращает текстовое представление типа 'Дата' на основе его описания. 
// Если тип 'Дата' отсутствует в описании, возвращается 'Неопределено'. 
// Также учитываются части даты и параметр 'ДляФорматтера' для формирования результата.
// 
// Параметры:
//  ОписаниеТипов         - Структура - Описание типов, содержащее информацию о типах данных, включая 'Дата'.
//  ПредставлениеНазвания - Строка    - Название типа, которое будет использоваться для формирования представления.
//  ДляФорматтера         - Булево    - Истина - часть даты добавляется без префикса 'ЧастиДаты.'.
// 
// Возвращаемое значение:
// Строка - Текстовое представление типа 'Дата' или 'Неопределено', если тип 'Дата' отсутствует.
&НаКлиенте
Функция ПолучитьПредставлениеТипаДаты(ОписаниеТипов, ПредставлениеНазвания, ДляФорматтера) Экспорт

	Если ОписаниеТипов.Типы.Найти("Дата") = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивПараметры = Новый Массив;  
	Если ОписаниеТипов.ЧастиДаты <> Неопределено
		И ОписаниеТипов.ЧастиДаты <> "ДатаВремя" Тогда  
		ТекЧастиДаты = ?(ДляФорматтера, "", "ЧастиДаты.") + ОписаниеТипов.ЧастиДаты;
		МассивПараметры.Добавить(ТекЧастиДаты);
	КонецЕсли;
	
	Если НЕ ДляФорматтера И МассивПараметры.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьПредставлениеОперации(ПредставлениеНазвания, МассивПараметры);

КонецФункции

// Функция возвращает представление типа строки на основе описания типов и параметров.
// 
// Параметры:
//  ОписаниеТипов         - Структура - Структура, содержащая описание типов, включая информацию о длине строки.
//  ПредставлениеНазвания - Строка    - Название типа, которое будет использоваться в представлении.
//  ДляФорматтера         - Булево    - Флаг, указывающий, используется ли представление для форматтера.
// 
// Возвращаемое значение:
// Строка - Представление типа строки или Неопределено, если тип не найден или параметры отсутствуют.
&НаКлиенте
Функция ПолучитьПредставлениеТипаСтроки(ОписаниеТипов, ПредставлениеНазвания, ДляФорматтера) Экспорт

	Если ОписаниеТипов.Типы.Найти("Строка") = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивПараметры = Новый Массив;  
	Если ОписаниеТипов.ДлинаСтроки <> Неопределено
		И ОписаниеТипов.ДлинаСтроки <> 0 Тогда
		МассивПараметры.Добавить(ОписаниеТипов.ДлинаСтроки);
	КонецЕсли;
	
	Если НЕ ДляФорматтера И МассивПараметры.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьПредставлениеОперации(ПредставлениеНазвания, МассивПараметры);

КонецФункции

// Функция возвращает текстовое представление типа числа на основе его описания, включая длину и точность числа.
// 
// Параметры:
//  ОписаниеТипов         - ОписаниеТипов - Структура, содержащая описание типов, включая информацию о числе.
//  ПредставлениеНазвания - Строка        - Название типа, которое будет использоваться для формирования представления.
//  ДляФорматтера         - Булево        - Флаг, указывающий, используется ли функция для форматтера.
// 
// Возвращаемое значение:
// Строка - Текстовое представление типа числа с указанными параметрами или Неопределено, если тип не найден.
&НаКлиенте
Функция ПолучитьПредставлениеТипаЧисла(ОписаниеТипов, ПредставлениеНазвания, ДляФорматтера) Экспорт

	Если ОписаниеТипов.Типы.Найти("Число") = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивПараметры = Новый Массив;  
	Если ОписаниеТипов.ДлинаЧисла <> Неопределено
		И ОписаниеТипов.ДлинаЧисла <> 0 Тогда
		МассивПараметры.Добавить(ОписаниеТипов.ДлинаЧисла);
	КонецЕсли;
	
	Если ОписаниеТипов.ТочностьЧисла <> Неопределено
		И ОписаниеТипов.ТочностьЧисла <> 0 Тогда
		МассивПараметры.Добавить(ОписаниеТипов.ТочностьЧисла);
	КонецЕсли;
	
	Если НЕ ДляФорматтера И МассивПараметры.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьПредставлениеОперации(ПредставлениеНазвания, МассивПараметры);

КонецФункции

// Приводит значение к допустимому типу данных на основе описания типов.
// 
// Параметры:
//  ОписаниеТипов - Структура - Описание типов, содержащее информацию о типах данных.
//  Значение      - Значение   - Значение, которое необходимо привести к допустимому типу.
// 
// Возвращаемое значение:
// Значение - Значение, приведенное к допустимому типу данных.
&НаКлиенте
Функция ПривестиЗначениеКДопустимомуТипу(ОписаниеТипов, Значение) Экспорт
	Результат = Значение;
	Если ОписаниеТипов.Типы.Найти("Дата") <> Неопределено Тогда
		Результат = СтрокуВДату(Значение); 
		Если Результат <> Неопределено Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Если ОписаниеТипов.Типы.Найти("Число") <> Неопределено Тогда
		Результат = СтрокуВЧисло(Значение); 
		Если Результат <> Неопределено Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Результат;
КонецФункции

// Определяет точность числа, вычисляя количество знаков после десятичной точки.
// 
// Параметры:
//  Значение - Строка - Строковое представление числа, для которого определяется точность.
// 
// Возвращаемое значение:
// Число - Количество знаков после десятичной точки.
&НаКлиенте
Функция ПолучитьТочностьЧисла(Знач Значение) Экспорт

	Значение = СтрЗаменить(Значение, ",", ".");
	МассивЧастейЧисла = СтрРазделить(Значение, ".");
	
	Если МассивЧастейЧисла.Количество() = 1 Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат СтрДлина(МассивЧастейЧисла[1]);

КонецФункции

// Определяет, является ли строка корректным представлением времени.
// 
// Параметры:
//  СтрокаВремя - Строка - Строка, представляющая время, которое необходимо проверить.
// 
// Возвращаемое значение:
// Булево - Истина, если строка является корректным временем, иначе Ложь.
&НаКлиенте
Функция ЭтоВремя(Знач СтрокаВремя) Экспорт

	Если ЭтоПустаяСтрокаВремя(СтрокаВремя) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ДлинаВремениБезДвоеточий = 4;
	ДлинаВремениСДвоеточием = 7;
	
	Если СтрДлина(СтрокаВремя) = ДлинаВремениБезДвоеточий 
		ИЛИ СтрДлина(СтрокаВремя) = ДлинаВремениСДвоеточием Тогда
		СтрокаВремя = "0" + СтрокаВремя;
	КонецЕсли;
	
	СтрокаВремя = "00010101" + СтрЗаменить(СтрокаВремя, ":", "");
	
	ОписаниеДаты = Новый ОписаниеТипов("Дата");
	Возврат ОписаниеДаты.ПривестиЗначение(СтрокаВремя) <> '00010101';

КонецФункции

// Проверяет, является ли строка корректной датой в формате 'дд.мм.гггг' или 'дд.мм.гг'.
// 
// Параметры:
//  СтрокаДата - Строка - Строка, которая проверяется на соответствие формату даты.
// 
// Возвращаемое значение:
// Булево - Истина, если строка является корректной датой, иначе Ложь.
&НаКлиенте
Функция ЭтоДата(СтрокаДата) Экспорт
	Если ЭтоПустаяСтрокаДата(СтрокаДата) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ДлинаКраткийФормат = 8;
	ДлинаДлинныйФормат = 10;
	
	Если СтрДлина(СтрокаДата) <> ДлинаКраткийФормат
		И СтрДлина(СтрокаДата) <> ДлинаДлинныйФормат Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	ПозицияПервойТочки = 3;
	ПозицияВторойТочки = 6;
	
	Если Сред(СтрокаДата, ПозицияПервойТочки, 1) <> "." 
		ИЛИ Сред(СтрокаДата, ПозицияВторойТочки, 1) <> "." Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	День = Лев(СтрокаДата, 2);
	Месяц = Сред(СтрокаДата, ПозицияПервойТочки + 1, 2);
	Год = Сред(СтрокаДата, ПозицияВторойТочки + 1);  
	
	Если СтрДлина(Год) = 2 Тогда
		Год = "20" + Год;
	КонецЕсли;	 
	
	ОписаниеДаты = Новый ОписаниеТипов("Дата");
	
	Возврат ОписаниеДаты.ПривестиЗначение(Год + Месяц + День) <> '00010101';

КонецФункции

// Определяет, является ли переданная строка датой, временем или датой и временем, и возвращает соответствующее значение.
// 
// Параметры:
//  СтрокаДатаВремя - Строка - Строка, которая проверяется на соответствие формату даты, времени или даты и времени.
// 
// Возвращаемое значение:
// Строка - 'Дата', 'Время', 'ДатаВремя' или Неопределено в зависимости от результата проверки.
&НаКлиенте
Функция ЭтоДатаВремя(Знач СтрокаДатаВремя) Экспорт

	СтрЧастиДаты = СтрРазделить(СтрокаДатаВремя, " ");
	
	Если СтрЧастиДаты.Количество() > 2 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	ЭтоДата = ЭтоДата(СтрЧастиДаты[0]); 
	
	Если ЭтоДата И СтрЧастиДаты.Количество() = 1 Тогда
		Возврат "Дата";	
	КонецЕсли;
	
	Если НЕ ЭтоДата И СтрЧастиДаты.Количество() = 2 Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	Если СтрЧастиДаты.Количество() = 2 Тогда		
		Если НЕ ЭтоДата ИЛИ НЕ ЭтоВремя(СтрЧастиДаты[1]) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат "ДатаВремя";
	КонецЕсли;
	
	Если ЭтоВремя(СтрЧастиДаты[0]) Тогда
		Возврат "Время";
	КонецЕсли;
	
	Возврат Неопределено;

КонецФункции

// Определяет, является ли переданное значение числом
// 
// Параметры:
//  Значение - Строка - Значение, которое необходимо проверить на принадлежность к числу
// 
// Возвращаемое значение:
// Булево - Истина, если значение является числом, иначе Ложь
&НаКлиенте
Функция ЭтоЧисло(Знач Значение) Экспорт

	Значение = СокрЛП(Значение);
	
	Значение = СтрЗаменить(Значение, ",", ".");
	
	СтрокаБезНулей = СтрЗаменить(Значение, "0", "");
	Если СтрНачинаетсяС(Значение, "0")
		И (СтрокаБезНулей = "" ИЛИ СтрокаБезНулей = ".") Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОписаниеЧисла = Новый ОписаниеТипов("Число");
	Возврат ОписаниеЧисла.ПривестиЗначение(Значение) <> 0;

КонецФункции

// Преобразует строковое представление даты/времени в значение типа Дата.
// 
// Параметры:
//  Значение - Строка - Строковое представление даты, времени или даты и времени
// 
// Возвращаемое значение:
// Дата - Преобразованное значение даты или Неопределено, если преобразование невозможно
&НаКлиенте
Функция СтрокуВДату(Знач Значение) Экспорт
	ТекЧастиДаты = ЭтоДатаВремя(Значение);
	
	Если ТекЧастиДаты = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	СтрЧастиДаты = СтрРазделить(Значение, " ");
	
	РезультатДата = "00010101";
	РезультатВремя = "000000";
	
	Если ТекЧастиДаты <> "Время" Тогда
		РезультатДата = СтрокуВДатуГМД(СтрЧастиДаты[0]);	
	КонецЕсли;
	
	Если ТекЧастиДаты = "Время" Тогда
		РезультатВремя = СтрокуВоВремя(СтрЧастиДаты[0]);	
	КонецЕсли;

	Если ТекЧастиДаты = "ДатаВремя" Тогда
		РезультатВремя = СтрокуВоВремя(СтрЧастиДаты[1]);	
	КонецЕсли;
	
	ОписаниеДаты = Новый ОписаниеТипов("Дата");
	Возврат ОписаниеДаты.ПривестиЗначение(РезультатДата + РезультатВремя);
КонецФункции

// Преобразует строковое представление числа в значение типа Число.
// 
// Параметры:
//  Значение - Строка - Строковое представление числа
// 
// Возвращаемое значение:
// Число - Преобразованное значение числа
&НаКлиенте
Функция СтрокуВЧисло(Знач Значение) Экспорт 
	ОписаниеЧисла = Новый ОписаниеТипов("Число");
	Возврат ОписаниеЧисла.ПривестиЗначение(Значение);
КонецФункции 

// Разбирает URL на составляющие части: протокол, сервер и адрес.
// 
// Параметры:
//  URL - Строка - URL для разбора
// 
// Возвращаемое значение:
// Структура - Структура с полями "Сервер", "Протокол", "Адрес"
&НаКлиенте
Функция РазобратьURL(Знач URL) Экспорт
	ПозицияРазделителяПротокола = 3;
	
	Протокол = "";
	Позиция = СтрНайти(URL, "://");
	Если Позиция > 0 Тогда
		Протокол = Лев(URL, Позиция - 1);
		URL = Сред(URL, Позиция + ПозицияРазделителяПротокола);
	КонецЕсли;
	
	Сервер = "";
	Позиция = СтрНайти(URL, "/");
	Если Позиция > 0 Тогда
		Сервер = Лев(URL, Позиция - 1);
		URL = Сред(URL, Позиция);
	Иначе
		Сервер = URL;
		URL = "";
	КонецЕсли;
	
	Адрес = URL;
	
	Результат = Новый Структура;
	Результат.Вставить("Сервер", Сервер);
	Результат.Вставить("Протокол", Протокол);
	Результат.Вставить("Адрес", Адрес);
	
	Возврат Результат;
	
КонецФункции

// Преобразует структуру или соответствие в JSON строку.
// 
// Параметры:
//  Объект - Произвольный - Объект для преобразования в JSON
// 
// Возвращаемое значение:
// Строка - JSON представление объекта
&НаКлиенте
Функция СтруктураВJSON(Объект) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Объект);
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Преобразует JSON строку в структуру.
// 
// Параметры:
//  СтрокаJSON - Строка - JSON строка для преобразования
// 
// Возвращаемое значение:
// Структура - Преобразованная структура или пустая структура при ошибке
&НаКлиенте
Функция JSONВСтруктуру(СтрокаJSON) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Попытка 
		Результат = ПрочитатьJSON(ЧтениеJSON);
	Исключение
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = НСтр("ru = 'Ошибка парсинга: '") + ОписаниеОшибки();
		Сообщение.Сообщить(); 
		Возврат Новый Структура;
	КонецПопытки;
	
	ЧтениеJSON.Закрыть();
	Возврат Результат;
КонецФункции

// Преобразует JSON строку в соответствие.
// 
// Параметры:
//  СтрокаJSON - Строка - JSON строка для преобразования
// 
// Возвращаемое значение:
// Соответствие - Преобразованное соответствие
&НаКлиенте
Функция JSONВСоответствие(СтрокаJSON) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Результат = ПрочитатьJSON(ЧтениеJSON, Истина);
	
	ЧтениеJSON.Закрыть();
	Возврат Результат;
КонецФункции

// УниверсальныеИнструменты - https://github.com/cpr1c/tools_ui_1c
// Объединяет компоненты файлового пути, с учетом разделителей, принятых в данной ОС. 
// При этом корректно, без дублирования, обрабатываются уже существующие разделители пути.
// 
// Параметры:
//  Путь1 - Строка - Первая часть пути
//  Путь2 - Строка - Вторая часть пути
//  Путь3 - Строка, Неопределено - Третья часть пути
//  Путь4 - Строка, Неопределено - Четвертая часть пути
// 
// Возвращаемое значение:
//  Строка - Объединенный путь.
&НаКлиенте
Функция ОбъединитьПути(Путь1, Путь2, Путь3 = Неопределено, Путь4 = Неопределено, Путь5 = Неопределено, Путь6 = Неопределено, Путь7 = Неопределено) Экспорт
	Разделитель = ПолучитьРазделительПути();
	
	МассивПути = Новый Массив;
	Если СтрЗаканчиваетсяНа(Путь1, Разделитель) Тогда
		МассивПути.Добавить(Лев(Путь1, СтрДлина(Путь1)-1));
	Иначе
		МассивПути.Добавить(Путь1);
	КонецЕсли;
	
	ДопПути = Новый Массив;
	ДопПути.Добавить(Путь2);
	
	Если ЗначениеЗаполнено(Путь3) Тогда
		ДопПути.Добавить(Путь3);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Путь4) Тогда
		ДопПути.Добавить(Путь4);
	КонецЕсли;

	Если ЗначениеЗаполнено(Путь5) Тогда
		ДопПути.Добавить(Путь5);
	КонецЕсли;

	Если ЗначениеЗаполнено(Путь6) Тогда
		ДопПути.Добавить(Путь6);
	КонецЕсли;

	Если ЗначениеЗаполнено(Путь7) Тогда
		ДопПути.Добавить(Путь7);
	КонецЕсли;
	
	Для Каждого ТекПуть Из ДопПути Цикл
		ПутьДляФинальногоПути = ТекПуть;
		Если СтрНачинаетсяС(ПутьДляФинальногоПути, Разделитель) Тогда
			ПутьДляФинальногоПути=Сред(ПутьДляФинальногоПути, 2);
		КонецЕсли;

		Если СтрЗаканчиваетсяНа(ПутьДляФинальногоПути, Разделитель) Тогда
			МассивПути.Добавить(Лев(ПутьДляФинальногоПути, СтрДлина(ПутьДляФинальногоПути) - 1));
		Иначе
			МассивПути.Добавить(ПутьДляФинальногоПути);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(МассивПути, Разделитель);
	
КонецФункции

// Раскладывает полное имя файла на составляющие.
//
// Параметры:
//  ПолноеИмяФайла - Строка - полный путь к файлу.
//  ЭтоПапка - Булево - признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура - имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - содержит путь к каталогу, в котором лежит файл.
//		Имя - содержит имя файла с расширением, без пути к файлу.
//		Расширение - содержит расширение файла.
//		ИмяБезРасширения - содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
//				ПолноеИмя: "c:\temp\test.txt".
//				Путь: "c:\temp\"
//				Имя: "test.txt"
//				Расширение: ".txt"
//				ИмяБезРасширения: "test".
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2019, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
//
// BSLLS:DuplicateStringLiteral-off
&НаКлиенте
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт

	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убираем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре.
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым, то остальные параметры структуры возвращаем пустыми.
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла.
	Если СтрНайти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = СтрНайти(ПолноеИмяФайла, "/", НаправлениеПоиска.СКонца);
	ИначеЕсли СтрНайти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = СтрНайти(ПолноеИмяФайла, "\", НаправлениеПоиска.СКонца);
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение.
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
		ПозицияТочки = СтрНайти(СтруктураИмениФайла.Имя, ".", НаправлениеПоиска.СКонца);
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции
// BSLLS:DuplicateStringLiteral-on

// Преобразует строку в формат, где каждое слово начинается с заглавной буквы.
// 
// Параметры:
//  Строка - Строка - Строка для преобразования
// 
// Возвращаемое значение:
//  Строка - Преобразованная строка
&НаКлиенте
Функция СтрокуВНотациюПаскаля(Знач Строка) Экспорт

	МассивСтрок = СтрРазделить(Строка, " ");
	
	МассивРезультат = Новый Массив;
	Для Каждого ТекСтрока Из МассивСтрок Цикл
		МассивРезультат.Добавить(ВРег(Лев(ТекСтрока, 1)) + Сред(ТекСтрока, 2));
	КонецЦикла;
	Результат = СтрСоединить(МассивРезультат, "");
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник) Экспорт
	Для Каждого Значение Из МассивИсточник Цикл
		МассивПриемник.Добавить(Значение);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти   

#Область СлужебныеПроцедурыИФункции

&НаКлиенте
Функция ФорматироватьЗначениеЧисло(Значение, ОписаниеТипов) 
	ФорматБезГруппировки = "ЧГ=0";
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить("ЧРД=."); 
	МассивПараметров.Добавить(ФорматБезГруппировки);
	ДлинаЧисла = ОписаниеТипов.ДлинаЧисла;
	Если ДлинаЧисла <> Неопределено И ДлинаЧисла <> 0 Тогда
		МассивПараметров.Добавить("ЧЦ=" + Формат(ДлинаЧисла, ФорматБезГруппировки));
	КонецЕсли;
	ТочностьЧисла = ОписаниеТипов.ТочностьЧисла;
	Если ТочностьЧисла <> Неопределено И ТочностьЧисла <> 0 Тогда
		МассивПараметров.Добавить("ЧДЦ=" + Формат(ТочностьЧисла, ФорматБезГруппировки));
		МассивПараметров.Добавить("ЧН=0." + СтрПовторитьСимвол("0", ТочностьЧисла));
	Иначе	
		МассивПараметров.Добавить("ЧН=0");
	КонецЕсли;	
	
	ФорматнаяСтрока = СтрСоединить(МассивПараметров, ";");
	Возврат Формат(Значение, ФорматнаяСтрока);;
КонецФункции

&НаКлиенте
Функция ФорматироватьЗначениеДата(Значение, ОписаниеТипов) 
	ФорматнаяСтрока = "ДФ='dd.MM.yyyy HH:mm:ss'; ДП='01.01.0001 00:00:00'";

	Если ОписаниеТипов.ЧастиДаты = "Дата" Тогда
		ФорматнаяСтрока = "ДФ='dd.MM.yyyy'; ДП='01.01.0001'";
	ИначеЕсли ОписаниеТипов.ЧастиДаты = "Время" Тогда 
		ФорматнаяСтрока = "ДФ='HH:mm:ss'; ДП='00:00:00'";
	Иначе
		ФорматнаяСтрока = "ДФ='dd.MM.yyyy HH:mm:ss'; ДП='01.01.0001 00:00:00'";
	КонецЕсли;
	
	Возврат Формат(Значение, ФорматнаяСтрока);;
КонецФункции

&НаКлиенте
Функция ЭтоПустаяСтрокаДата(СтрокаДата)
	Если СтрокаДата = "01.01.01" Тогда
		Возврат Истина;
	КонецЕсли;

	Если СтрокаДата = "01.01.0001" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции 

&НаКлиенте
Функция ЭтоПустаяСтрокаВремя(СтрокаВремя)
	Возврат СтрокаВремя = "0:00"
		ИЛИ СтрокаВремя = "00:00" 
		ИЛИ СтрокаВремя = "0:00:00"
		ИЛИ СтрокаВремя = "00:00:00";  
КонецФункции 

&НаКлиенте
Функция СтрокуВДатуГМД(СтрокаДата)
	Если ЭтоПустаяСтрокаДата(СтрокаДата) Тогда
		Возврат "00010101";	
	КонецЕсли;

	ПозицияМесяца = 4;
	ПозицияГода = 7;
	
	День = Лев(СтрокаДата, 2);
	Месяц = Сред(СтрокаДата, ПозицияМесяца, 2);
	Год = Сред(СтрокаДата, ПозицияГода);  
	
	Если СтрДлина(Год) = 2 Тогда
		Год = "20" + Год;
	КонецЕсли;	 

	Возврат Год + Месяц + День;
КонецФункции

&НаКлиенте
Функция СтрокуВоВремя(Знач СтрокаВремя)
	Если ЭтоПустаяСтрокаВремя(СтрокаВремя) Тогда
		Возврат "000000";	
	КонецЕсли;

	ДлинаКраткийФормат = 3;
	ДлинкКраткийФорматСПолнымФорматомЧасов = 4;
	ДлинаДлинныйФормат = 5;
	
	СтрокаВремя = СтрЗаменить(СтрокаВремя, ":", "");
	
	Если СтрДлина(СтрокаВремя) = ДлинаКраткийФормат 
		ИЛИ СтрДлина(СтрокаВремя) = ДлинаДлинныйФормат Тогда
		СтрокаВремя = "0" + СтрокаВремя;
	КонецЕсли;
	
	Если СтрДлина(СтрокаВремя) = ДлинкКраткийФорматСПолнымФорматомЧасов Тогда
		СтрокаВремя = СтрокаВремя + "00";
	КонецЕсли;  
	
	Возврат СтрокаВремя;
КонецФункции

&НаКлиенте
Функция СтрПовторитьСимвол(Символ, Количество)
	Если Количество <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	Для Сч = 1 По Количество Цикл // BSLLS:UnusedLocalVariable-off
		Результат = Результат + Символ;
	КонецЦикла;
	Возврат Результат;
КонецФункции

#КонецОбласти

