/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./parser/app.js":
/*!***********************!*\
  !*** ./parser/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lexer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer.js */ \"./parser/lexer.js\");\n/* harmony import */ var _group_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group-parser.js */ \"./parser/group-parser.js\");\n/* harmony import */ var _visitor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visitor.js */ \"./parser/visitor.js\");\n// MIT License\r\n\r\n// Copyright (c) 2025 Zherebtsov Nikita <nikita@crimsongold.ru>\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\n// https://github.com/crimsongoldteam/md_design\r\n\r\n\r\n\r\n\r\n\r\nfunction parseInput(input) {\r\n  let resultJSON = \"\";\r\n\r\n  let lexingResult = _lexer_js__WEBPACK_IMPORTED_MODULE_0__.lexer.tokenize(input);  \r\n  _group_parser_js__WEBPACK_IMPORTED_MODULE_1__.groupParser.input = lexingResult.tokens;\r\n\r\n  let cst = _group_parser_js__WEBPACK_IMPORTED_MODULE_1__.groupParser.Form();\r\n\r\n  const result = _visitor_js__WEBPACK_IMPORTED_MODULE_2__.visitor.visit(cst);\r\n\r\n  resultJSON = JSON.stringify(result, null, 2);\r\n//   let resultJSON = \"\";\r\n//   if (window.lexer === null) {\r\n//     Load();\r\n//   }\r\n\r\n//   try {\r\n//     let lexingResult = lexer.tokenize(input);\r\n\r\n//     window.groupParser.input = lexingResult.tokens;\r\n\r\n//     let cst = groupParser.Form();\r\n\r\n//     const result = visitor.visit(cst);\r\n\r\n//     \r\n//   } catch (e) {\r\n//     return \"Ошибка: \" + e.name + \":\" + e.message + \"\\n\" + e.stack;\r\n//   }\r\n  //  return resultJSON;\r\n  return resultJSON;  \r\n}\r\n\r\nwindow.parseInput = parseInput;\r\n\r\n\n\n//# sourceURL=webpack:///./parser/app.js?");

/***/ }),

/***/ "./parser/chevrotain.js":
/*!******************************!*\
  !*** ./parser/chevrotain.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alternation: () => (/* binding */ Alternation),\n/* harmony export */   Alternative: () => (/* binding */ Alternative),\n/* harmony export */   CstParser: () => (/* binding */ CstParser),\n/* harmony export */   EMPTY_ALT: () => (/* binding */ EMPTY_ALT),\n/* harmony export */   EOF: () => (/* binding */ EOF),\n/* harmony export */   EarlyExitException: () => (/* binding */ EarlyExitException),\n/* harmony export */   EmbeddedActionsParser: () => (/* binding */ EmbeddedActionsParser),\n/* harmony export */   GAstVisitor: () => (/* binding */ GAstVisitor),\n/* harmony export */   LLkLookaheadStrategy: () => (/* binding */ LLkLookaheadStrategy),\n/* harmony export */   Lexer: () => (/* binding */ Lexer),\n/* harmony export */   LexerDefinitionErrorType: () => (/* binding */ LexerDefinitionErrorType),\n/* harmony export */   MismatchedTokenException: () => (/* binding */ MismatchedTokenException),\n/* harmony export */   NoViableAltException: () => (/* binding */ NoViableAltException),\n/* harmony export */   NonTerminal: () => (/* binding */ NonTerminal),\n/* harmony export */   NotAllInputParsedException: () => (/* binding */ NotAllInputParsedException),\n/* harmony export */   Option: () => (/* binding */ Option),\n/* harmony export */   Parser: () => (/* binding */ Parser2),\n/* harmony export */   ParserDefinitionErrorType: () => (/* binding */ ParserDefinitionErrorType),\n/* harmony export */   Repetition: () => (/* binding */ Repetition),\n/* harmony export */   RepetitionMandatory: () => (/* binding */ RepetitionMandatory),\n/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* binding */ RepetitionMandatoryWithSeparator),\n/* harmony export */   RepetitionWithSeparator: () => (/* binding */ RepetitionWithSeparator),\n/* harmony export */   Rule: () => (/* binding */ Rule),\n/* harmony export */   Terminal: () => (/* binding */ Terminal),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   createSyntaxDiagramsCode: () => (/* binding */ createSyntaxDiagramsCode),\n/* harmony export */   createToken: () => (/* binding */ createToken),\n/* harmony export */   createTokenInstance: () => (/* binding */ createTokenInstance),\n/* harmony export */   defaultLexerErrorProvider: () => (/* binding */ defaultLexerErrorProvider),\n/* harmony export */   defaultParserErrorProvider: () => (/* binding */ defaultParserErrorProvider),\n/* harmony export */   generateCstDts: () => (/* binding */ generateCstDts),\n/* harmony export */   getLookaheadPaths: () => (/* binding */ getLookaheadPaths),\n/* harmony export */   isRecognitionException: () => (/* binding */ isRecognitionException),\n/* harmony export */   serializeGrammar: () => (/* binding */ serializeGrammar),\n/* harmony export */   serializeProduction: () => (/* binding */ serializeProduction),\n/* harmony export */   tokenLabel: () => (/* binding */ tokenLabel2),\n/* harmony export */   tokenMatcher: () => (/* binding */ tokenMatcher),\n/* harmony export */   tokenName: () => (/* binding */ tokenName)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n// lib/src/version.js\nvar VERSION = \"11.0.3\";\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js\nvar freeGlobal = typeof __webpack_require__.g == \"object\" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\nvar freeGlobal_default = freeGlobal;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = freeGlobal_default || freeSelf || Function(\"return this\")();\nvar root_default = root;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js\nvar Symbol = root_default.Symbol;\nvar Symbol_default = Symbol;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar nativeObjectToString = objectProto.toString;\nvar symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = void 0;\n    var unmasked = true;\n  } catch (e) {\n  }\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nvar getRawTag_default = getRawTag;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js\nvar objectProto2 = Object.prototype;\nvar nativeObjectToString2 = objectProto2.toString;\nfunction objectToString(value) {\n  return nativeObjectToString2.call(value);\n}\nvar objectToString_default = objectToString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);\n}\nvar baseGetTag_default = baseGetTag;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_default = isObjectLike;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js\nvar symbolTag = \"[object Symbol]\";\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;\n}\nvar isSymbol_default = isSymbol;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js\nfunction arrayMap(array, iteratee) {\n  var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\nvar arrayMap_default = arrayMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js\nvar isArray = Array.isArray;\nvar isArray_default = isArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js\nvar INFINITY = 1 / 0;\nvar symbolProto = Symbol_default ? Symbol_default.prototype : void 0;\nvar symbolToString = symbolProto ? symbolProto.toString : void 0;\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n  if (isArray_default(value)) {\n    return arrayMap_default(value, baseToString) + \"\";\n  }\n  if (isSymbol_default(value)) {\n    return symbolToString ? symbolToString.call(value) : \"\";\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nvar baseToString_default = baseToString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_trimmedEndIndex.js\nvar reWhitespace = /\\s/;\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n  while (index-- && reWhitespace.test(string.charAt(index))) {\n  }\n  return index;\n}\nvar trimmedEndIndex_default = trimmedEndIndex;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTrim.js\nvar reTrimStart = /^\\s+/;\nfunction baseTrim(string) {\n  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, \"\") : string;\n}\nvar baseTrim_default = baseTrim;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_default = isObject;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js\nvar NAN = 0 / 0;\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\nvar reIsBinary = /^0b[01]+$/i;\nvar reIsOctal = /^0o[0-7]+$/i;\nvar freeParseInt = parseInt;\nfunction toNumber(value) {\n  if (typeof value == \"number\") {\n    return value;\n  }\n  if (isSymbol_default(value)) {\n    return NAN;\n  }\n  if (isObject_default(value)) {\n    var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n    value = isObject_default(other) ? other + \"\" : other;\n  }\n  if (typeof value != \"string\") {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim_default(value);\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\nvar toNumber_default = toNumber;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toFinite.js\nvar INFINITY2 = 1 / 0;\nvar MAX_INTEGER = 17976931348623157e292;\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber_default(value);\n  if (value === INFINITY2 || value === -INFINITY2) {\n    var sign = value < 0 ? -1 : 1;\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\nvar toFinite_default = toFinite;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toInteger.js\nfunction toInteger(value) {\n  var result = toFinite_default(value), remainder = result % 1;\n  return result === result ? remainder ? result - remainder : result : 0;\n}\nvar toInteger_default = toInteger;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js\nfunction identity(value) {\n  return value;\n}\nvar identity_default = identity;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js\nvar asyncTag = \"[object AsyncFunction]\";\nvar funcTag = \"[object Function]\";\nvar genTag = \"[object GeneratorFunction]\";\nvar proxyTag = \"[object Proxy]\";\nfunction isFunction(value) {\n  if (!isObject_default(value)) {\n    return false;\n  }\n  var tag = baseGetTag_default(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_default = isFunction;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js\nvar coreJsData = root_default[\"__core-js_shared__\"];\nvar coreJsData_default = coreJsData;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js\nvar maskSrcKey = function() {\n  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar isMasked_default = isMasked;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {\n    }\n    try {\n      return func + \"\";\n    } catch (e) {\n    }\n  }\n  return \"\";\n}\nvar toSource_default = toSource;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto2 = Function.prototype;\nvar objectProto3 = Object.prototype;\nvar funcToString2 = funcProto2.toString;\nvar hasOwnProperty2 = objectProto3.hasOwnProperty;\nvar reIsNative = RegExp(\n  \"^\" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative(value) {\n  if (!isObject_default(value) || isMasked_default(value)) {\n    return false;\n  }\n  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource_default(value));\n}\nvar baseIsNative_default = baseIsNative;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js\nfunction getValue(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar getValue_default = getValue;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js\nfunction getNative(object, key) {\n  var value = getValue_default(object, key);\n  return baseIsNative_default(value) ? value : void 0;\n}\nvar getNative_default = getNative;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js\nvar WeakMap = getNative_default(root_default, \"WeakMap\");\nvar WeakMap_default = WeakMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js\nvar objectCreate = Object.create;\nvar baseCreate = function() {\n  function object() {\n  }\n  return function(proto) {\n    if (!isObject_default(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object();\n    object.prototype = void 0;\n    return result;\n  };\n}();\nvar baseCreate_default = baseCreate;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n    case 1:\n      return func.call(thisArg, args[0]);\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\nvar apply_default = apply;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js\nfunction noop() {\n}\nvar noop_default = noop;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js\nfunction copyArray(source, array) {\n  var index = -1, length = source.length;\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\nvar copyArray_default = copyArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js\nvar HOT_COUNT = 800;\nvar HOT_SPAN = 16;\nvar nativeNow = Date.now;\nfunction shortOut(func) {\n  var count = 0, lastCalled = 0;\n  return function() {\n    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(void 0, arguments);\n  };\n}\nvar shortOut_default = shortOut;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\nvar constant_default = constant;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js\nvar defineProperty = function() {\n  try {\n    var func = getNative_default(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e) {\n  }\n}();\nvar defineProperty_default = defineProperty;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js\nvar baseSetToString = !defineProperty_default ? identity_default : function(func, string) {\n  return defineProperty_default(func, \"toString\", {\n    \"configurable\": true,\n    \"enumerable\": false,\n    \"value\": constant_default(string),\n    \"writable\": true\n  });\n};\nvar baseSetToString_default = baseSetToString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js\nvar setToString = shortOut_default(baseSetToString_default);\nvar setToString_default = setToString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEach.js\nfunction arrayEach(array, iteratee) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\nvar arrayEach_default = arrayEach;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindIndex.js\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\nvar baseFindIndex_default = baseFindIndex;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNaN.js\nfunction baseIsNaN(value) {\n  return value !== value;\n}\nvar baseIsNaN_default = baseIsNaN;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictIndexOf.js\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1, length = array.length;\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\nvar strictIndexOf_default = strictIndexOf;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOf.js\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);\n}\nvar baseIndexOf_default = baseIndexOf;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludes.js\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf_default(array, value, 0) > -1;\n}\nvar arrayIncludes_default = arrayIncludes;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n}\nvar isIndex_default = isIndex;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js\nfunction baseAssignValue(object, key, value) {\n  if (key == \"__proto__\" && defineProperty_default) {\n    defineProperty_default(object, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value,\n      \"writable\": true\n    });\n  } else {\n    object[key] = value;\n  }\n}\nvar baseAssignValue_default = baseAssignValue;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_default = eq;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js\nvar objectProto4 = Object.prototype;\nvar hasOwnProperty3 = objectProto4.hasOwnProperty;\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {\n    baseAssignValue_default(object, key, value);\n  }\n}\nvar assignValue_default = assignValue;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyObject.js\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n  var index = -1, length = props.length;\n  while (++index < length) {\n    var key = props[index];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue_default(object, key, newValue);\n    } else {\n      assignValue_default(object, key, newValue);\n    }\n  }\n  return object;\n}\nvar copyObject_default = copyObject;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js\nvar nativeMax = Math.max;\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);\n  return function() {\n    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply_default(func, this, otherArgs);\n  };\n}\nvar overRest_default = overRest;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js\nfunction baseRest(func, start) {\n  return setToString_default(overRest_default(func, start, identity_default), func + \"\");\n}\nvar baseRest_default = baseRest;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js\nvar MAX_SAFE_INTEGER2 = 9007199254740991;\nfunction isLength(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;\n}\nvar isLength_default = isLength;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js\nfunction isArrayLike(value) {\n  return value != null && isLength_default(value.length) && !isFunction_default(value);\n}\nvar isArrayLike_default = isArrayLike;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js\nfunction isIterateeCall(value, index, object) {\n  if (!isObject_default(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == \"number\" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == \"string\" && index in object) {\n    return eq_default(object[index], value);\n  }\n  return false;\n}\nvar isIterateeCall_default = isIterateeCall;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAssigner.js\nfunction createAssigner(assigner) {\n  return baseRest_default(function(object, sources) {\n    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;\n    customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : void 0;\n    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? void 0 : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\nvar createAssigner_default = createAssigner;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js\nvar objectProto5 = Object.prototype;\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto5;\n  return value === proto;\n}\nvar isPrototype_default = isPrototype;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js\nfunction baseTimes(n, iteratee) {\n  var index = -1, result = Array(n);\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\nvar baseTimes_default = baseTimes;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js\nvar argsTag = \"[object Arguments]\";\nfunction baseIsArguments(value) {\n  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;\n}\nvar baseIsArguments_default = baseIsArguments;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js\nvar objectProto6 = Object.prototype;\nvar hasOwnProperty4 = objectProto6.hasOwnProperty;\nvar propertyIsEnumerable = objectProto6.propertyIsEnumerable;\nvar isArguments = baseIsArguments_default(function() {\n  return arguments;\n}()) ? baseIsArguments_default : function(value) {\n  return isObjectLike_default(value) && hasOwnProperty4.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n};\nvar isArguments_default = isArguments;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js\nfunction stubFalse() {\n  return false;\n}\nvar stubFalse_default = stubFalse;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js\nvar freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\nvar moduleExports = freeModule && freeModule.exports === freeExports;\nvar Buffer = moduleExports ? root_default.Buffer : void 0;\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;\nvar isBuffer = nativeIsBuffer || stubFalse_default;\nvar isBuffer_default = isBuffer;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js\nvar argsTag2 = \"[object Arguments]\";\nvar arrayTag = \"[object Array]\";\nvar boolTag = \"[object Boolean]\";\nvar dateTag = \"[object Date]\";\nvar errorTag = \"[object Error]\";\nvar funcTag2 = \"[object Function]\";\nvar mapTag = \"[object Map]\";\nvar numberTag = \"[object Number]\";\nvar objectTag = \"[object Object]\";\nvar regexpTag = \"[object RegExp]\";\nvar setTag = \"[object Set]\";\nvar stringTag = \"[object String]\";\nvar weakMapTag = \"[object WeakMap]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\";\nvar dataViewTag = \"[object DataView]\";\nvar float32Tag = \"[object Float32Array]\";\nvar float64Tag = \"[object Float64Array]\";\nvar int8Tag = \"[object Int8Array]\";\nvar int16Tag = \"[object Int16Array]\";\nvar int32Tag = \"[object Int32Array]\";\nvar uint8Tag = \"[object Uint8Array]\";\nvar uint8ClampedTag = \"[object Uint8ClampedArray]\";\nvar uint16Tag = \"[object Uint16Array]\";\nvar uint32Tag = \"[object Uint32Array]\";\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\nfunction baseIsTypedArray(value) {\n  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];\n}\nvar baseIsTypedArray_default = baseIsTypedArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar baseUnary_default = baseUnary;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js\nvar freeExports2 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule2 = freeExports2 && \"object\" == \"object\" && module && !module.nodeType && module;\nvar moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;\nvar freeProcess = moduleExports2 && freeGlobal_default.process;\nvar nodeUtil = function() {\n  try {\n    var types = freeModule2 && freeModule2.require && freeModule2.require(\"util\").types;\n    if (types) {\n      return types;\n    }\n    return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n  } catch (e) {\n  }\n}();\nvar nodeUtil_default = nodeUtil;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js\nvar nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;\nvar isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;\nvar isTypedArray_default = isTypedArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js\nvar objectProto7 = Object.prototype;\nvar hasOwnProperty5 = objectProto7.hasOwnProperty;\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;\n  for (var key in value) {\n    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n    isIndex_default(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar arrayLikeKeys_default = arrayLikeKeys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar overArg_default = overArg;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js\nvar nativeKeys = overArg_default(Object.keys, Object);\nvar nativeKeys_default = nativeKeys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js\nvar objectProto8 = Object.prototype;\nvar hasOwnProperty6 = objectProto8.hasOwnProperty;\nfunction baseKeys(object) {\n  if (!isPrototype_default(object)) {\n    return nativeKeys_default(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty6.call(object, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar baseKeys_default = baseKeys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js\nfunction keys(object) {\n  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);\n}\nvar keys_default = keys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assign.js\nvar objectProto9 = Object.prototype;\nvar hasOwnProperty7 = objectProto9.hasOwnProperty;\nvar assign = createAssigner_default(function(object, source) {\n  if (isPrototype_default(source) || isArrayLike_default(source)) {\n    copyObject_default(source, keys_default(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty7.call(source, key)) {\n      assignValue_default(object, key, source[key]);\n    }\n  }\n});\nvar assign_default = assign;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar nativeKeysIn_default = nativeKeysIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js\nvar objectProto10 = Object.prototype;\nvar hasOwnProperty8 = objectProto10.hasOwnProperty;\nfunction baseKeysIn(object) {\n  if (!isObject_default(object)) {\n    return nativeKeysIn_default(object);\n  }\n  var isProto = isPrototype_default(object), result = [];\n  for (var key in object) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty8.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar baseKeysIn_default = baseKeysIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js\nfunction keysIn(object) {\n  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);\n}\nvar keysIn_default = keysIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\nfunction isKey(value, object) {\n  if (isArray_default(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol_default(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\nvar isKey_default = isKey;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js\nvar nativeCreate = getNative_default(Object, \"create\");\nvar nativeCreate_default = nativeCreate;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js\nfunction hashClear() {\n  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};\n  this.size = 0;\n}\nvar hashClear_default = hashClear;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar hashDelete_default = hashDelete;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nvar objectProto11 = Object.prototype;\nvar hasOwnProperty9 = objectProto11.hasOwnProperty;\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate_default) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? void 0 : result;\n  }\n  return hasOwnProperty9.call(data, key) ? data[key] : void 0;\n}\nvar hashGet_default = hashGet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js\nvar objectProto12 = Object.prototype;\nvar hasOwnProperty10 = objectProto12.hasOwnProperty;\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty10.call(data, key);\n}\nvar hashHas_default = hashHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js\nvar HASH_UNDEFINED2 = \"__lodash_hash_undefined__\";\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;\n  return this;\n}\nvar hashSet_default = hashSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js\nfunction Hash(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash.prototype.clear = hashClear_default;\nHash.prototype[\"delete\"] = hashDelete_default;\nHash.prototype.get = hashGet_default;\nHash.prototype.has = hashHas_default;\nHash.prototype.set = hashSet_default;\nvar Hash_default = Hash;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar listCacheClear_default = listCacheClear;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_default(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar assocIndexOf_default = assocIndexOf;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete(key) {\n  var data = this.__data__, index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\nvar listCacheDelete_default = listCacheDelete;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js\nfunction listCacheGet(key) {\n  var data = this.__data__, index = assocIndexOf_default(data, key);\n  return index < 0 ? void 0 : data[index][1];\n}\nvar listCacheGet_default = listCacheGet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js\nfunction listCacheHas(key) {\n  return assocIndexOf_default(this.__data__, key) > -1;\n}\nvar listCacheHas_default = listCacheHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js\nfunction listCacheSet(key, value) {\n  var data = this.__data__, index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\nvar listCacheSet_default = listCacheSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js\nfunction ListCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache.prototype.clear = listCacheClear_default;\nListCache.prototype[\"delete\"] = listCacheDelete_default;\nListCache.prototype.get = listCacheGet_default;\nListCache.prototype.has = listCacheHas_default;\nListCache.prototype.set = listCacheSet_default;\nvar ListCache_default = ListCache;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js\nvar Map2 = getNative_default(root_default, \"Map\");\nvar Map_default = Map2;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash_default(),\n    \"map\": new (Map_default || ListCache_default)(),\n    \"string\": new Hash_default()\n  };\n}\nvar mapCacheClear_default = mapCacheClear;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar isKeyable_default = isKeyable;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js\nfunction getMapData(map2, key) {\n  var data = map2.__data__;\n  return isKeyable_default(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar getMapData_default = getMapData;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js\nfunction mapCacheDelete(key) {\n  var result = getMapData_default(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar mapCacheDelete_default = mapCacheDelete;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js\nfunction mapCacheGet(key) {\n  return getMapData_default(this, key).get(key);\n}\nvar mapCacheGet_default = mapCacheGet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js\nfunction mapCacheHas(key) {\n  return getMapData_default(this, key).has(key);\n}\nvar mapCacheHas_default = mapCacheHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js\nfunction mapCacheSet(key, value) {\n  var data = getMapData_default(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar mapCacheSet_default = mapCacheSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js\nfunction MapCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache.prototype.clear = mapCacheClear_default;\nMapCache.prototype[\"delete\"] = mapCacheDelete_default;\nMapCache.prototype.get = mapCacheGet_default;\nMapCache.prototype.has = mapCacheHas_default;\nMapCache.prototype.set = mapCacheSet_default;\nvar MapCache_default = MapCache;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache_default)();\n  return memoized;\n}\nmemoize.Cache = MapCache_default;\nvar memoize_default = memoize;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js\nvar MAX_MEMOIZE_SIZE = 500;\nfunction memoizeCapped(func) {\n  var result = memoize_default(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n  var cache = result.cache;\n  return result;\n}\nvar memoizeCapped_default = memoizeCapped;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar stringToPath = memoizeCapped_default(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n  });\n  return result;\n});\nvar stringToPath_default = stringToPath;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js\nfunction toString(value) {\n  return value == null ? \"\" : baseToString_default(value);\n}\nvar toString_default = toString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js\nfunction castPath(value, object) {\n  if (isArray_default(value)) {\n    return value;\n  }\n  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));\n}\nvar castPath_default = castPath;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js\nvar INFINITY3 = 1 / 0;\nfunction toKey(value) {\n  if (typeof value == \"string\" || isSymbol_default(value)) {\n    return value;\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY3 ? \"-0\" : result;\n}\nvar toKey_default = toKey;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js\nfunction baseGet(object, path) {\n  path = castPath_default(path, object);\n  var index = 0, length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey_default(path[index++])];\n  }\n  return index && index == length ? object : void 0;\n}\nvar baseGet_default = baseGet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js\nfunction get(object, path, defaultValue) {\n  var result = object == null ? void 0 : baseGet_default(object, path);\n  return result === void 0 ? defaultValue : result;\n}\nvar get_default = get;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js\nfunction arrayPush(array, values2) {\n  var index = -1, length = values2.length, offset = array.length;\n  while (++index < length) {\n    array[offset + index] = values2[index];\n  }\n  return array;\n}\nvar arrayPush_default = arrayPush;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isFlattenable.js\nvar spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;\nfunction isFlattenable(value) {\n  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\nvar isFlattenable_default = isFlattenable;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFlatten.js\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1, length = array.length;\n  predicate || (predicate = isFlattenable_default);\n  result || (result = []);\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush_default(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\nvar baseFlatten_default = baseFlatten;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatten.js\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten_default(array, 1) : [];\n}\nvar flatten_default = flatten;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js\nvar getPrototype = overArg_default(Object.getPrototypeOf, Object);\nvar getPrototype_default = getPrototype;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSlice.js\nfunction baseSlice(array, start, end) {\n  var index = -1, length = array.length;\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\nvar baseSlice_default = baseSlice;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castSlice.js\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === void 0 ? length : end;\n  return !start && end >= length ? array : baseSlice_default(array, start, end);\n}\nvar castSlice_default = castSlice;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasUnicode.js\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\";\nvar reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\";\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\nvar rsZWJ = \"\\\\u200d\";\nvar reHasUnicode = RegExp(\"[\" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + \"]\");\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\nvar hasUnicode_default = hasUnicode;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_asciiToArray.js\nfunction asciiToArray(string) {\n  return string.split(\"\");\n}\nvar asciiToArray_default = asciiToArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_unicodeToArray.js\nvar rsAstralRange2 = \"\\\\ud800-\\\\udfff\";\nvar rsComboMarksRange2 = \"\\\\u0300-\\\\u036f\";\nvar reComboHalfMarksRange2 = \"\\\\ufe20-\\\\ufe2f\";\nvar rsComboSymbolsRange2 = \"\\\\u20d0-\\\\u20ff\";\nvar rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;\nvar rsVarRange2 = \"\\\\ufe0e\\\\ufe0f\";\nvar rsAstral = \"[\" + rsAstralRange2 + \"]\";\nvar rsCombo = \"[\" + rsComboRange2 + \"]\";\nvar rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\";\nvar rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\";\nvar rsNonAstral = \"[^\" + rsAstralRange2 + \"]\";\nvar rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\";\nvar rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\";\nvar rsZWJ2 = \"\\\\u200d\";\nvar reOptMod = rsModifier + \"?\";\nvar rsOptVar = \"[\" + rsVarRange2 + \"]?\";\nvar rsOptJoin = \"(?:\" + rsZWJ2 + \"(?:\" + [rsNonAstral, rsRegional, rsSurrPair].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\";\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\" + [rsNonAstral + rsCombo + \"?\", rsCombo, rsRegional, rsSurrPair, rsAstral].join(\"|\") + \")\";\nvar reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\nvar unicodeToArray_default = unicodeToArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToArray.js\nfunction stringToArray(string) {\n  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);\n}\nvar stringToArray_default = stringToArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createCaseFirst.js\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString_default(string);\n    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;\n    var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join(\"\") : string.slice(1);\n    return chr[methodName]() + trailing;\n  };\n}\nvar createCaseFirst_default = createCaseFirst;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/upperFirst.js\nvar upperFirst = createCaseFirst_default(\"toUpperCase\");\nvar upperFirst_default = upperFirst;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayReduce.js\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1, length = array == null ? 0 : array.length;\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\nvar arrayReduce_default = arrayReduce;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js\nfunction stackClear() {\n  this.__data__ = new ListCache_default();\n  this.size = 0;\n}\nvar stackClear_default = stackClear;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js\nfunction stackDelete(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nvar stackDelete_default = stackDelete;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\nvar stackGet_default = stackGet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\nvar stackHas_default = stackHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js\nvar LARGE_ARRAY_SIZE = 200;\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache_default) {\n    var pairs = data.__data__;\n    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache_default(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\nvar stackSet_default = stackSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache_default(entries);\n  this.size = data.size;\n}\nStack.prototype.clear = stackClear_default;\nStack.prototype[\"delete\"] = stackDelete_default;\nStack.prototype.get = stackGet_default;\nStack.prototype.has = stackHas_default;\nStack.prototype.set = stackSet_default;\nvar Stack_default = Stack;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssign.js\nfunction baseAssign(object, source) {\n  return object && copyObject_default(source, keys_default(source), object);\n}\nvar baseAssign_default = baseAssign;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignIn.js\nfunction baseAssignIn(object, source) {\n  return object && copyObject_default(source, keysIn_default(source), object);\n}\nvar baseAssignIn_default = baseAssignIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneBuffer.js\nvar freeExports3 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule3 = freeExports3 && \"object\" == \"object\" && module && !module.nodeType && module;\nvar moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;\nvar Buffer2 = moduleExports3 ? root_default.Buffer : void 0;\nvar allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n  buffer.copy(result);\n  return result;\n}\nvar cloneBuffer_default = cloneBuffer;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js\nfunction arrayFilter(array, predicate) {\n  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar arrayFilter_default = arrayFilter;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js\nfunction stubArray() {\n  return [];\n}\nvar stubArray_default = stubArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js\nvar objectProto13 = Object.prototype;\nvar propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\nvar getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable2.call(object, symbol);\n  });\n};\nvar getSymbols_default = getSymbols;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbols.js\nfunction copySymbols(source, object) {\n  return copyObject_default(source, getSymbols_default(source), object);\n}\nvar copySymbols_default = copySymbols;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbolsIn.js\nvar nativeGetSymbols2 = Object.getOwnPropertySymbols;\nvar getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush_default(result, getSymbols_default(object));\n    object = getPrototype_default(object);\n  }\n  return result;\n};\nvar getSymbolsIn_default = getSymbolsIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbolsIn.js\nfunction copySymbolsIn(source, object) {\n  return copyObject_default(source, getSymbolsIn_default(source), object);\n}\nvar copySymbolsIn_default = copySymbolsIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));\n}\nvar baseGetAllKeys_default = baseGetAllKeys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js\nfunction getAllKeys(object) {\n  return baseGetAllKeys_default(object, keys_default, getSymbols_default);\n}\nvar getAllKeys_default = getAllKeys;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeysIn.js\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);\n}\nvar getAllKeysIn_default = getAllKeysIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js\nvar DataView = getNative_default(root_default, \"DataView\");\nvar DataView_default = DataView;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js\nvar Promise2 = getNative_default(root_default, \"Promise\");\nvar Promise_default = Promise2;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js\nvar Set = getNative_default(root_default, \"Set\");\nvar Set_default = Set;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js\nvar mapTag2 = \"[object Map]\";\nvar objectTag2 = \"[object Object]\";\nvar promiseTag = \"[object Promise]\";\nvar setTag2 = \"[object Set]\";\nvar weakMapTag2 = \"[object WeakMap]\";\nvar dataViewTag2 = \"[object DataView]\";\nvar dataViewCtorString = toSource_default(DataView_default);\nvar mapCtorString = toSource_default(Map_default);\nvar promiseCtorString = toSource_default(Promise_default);\nvar setCtorString = toSource_default(Set_default);\nvar weakMapCtorString = toSource_default(WeakMap_default);\nvar getTag = baseGetTag_default;\nif (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {\n  getTag = function(value) {\n    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString:\n          return dataViewTag2;\n        case mapCtorString:\n          return mapTag2;\n        case promiseCtorString:\n          return promiseTag;\n        case setCtorString:\n          return setTag2;\n        case weakMapCtorString:\n          return weakMapTag2;\n      }\n    }\n    return result;\n  };\n}\nvar getTag_default = getTag;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneArray.js\nvar objectProto14 = Object.prototype;\nvar hasOwnProperty11 = objectProto14.hasOwnProperty;\nfunction initCloneArray(array) {\n  var length = array.length, result = new array.constructor(length);\n  if (length && typeof array[0] == \"string\" && hasOwnProperty11.call(array, \"index\")) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\nvar initCloneArray_default = initCloneArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js\nvar Uint8Array = root_default.Uint8Array;\nvar Uint8Array_default = Uint8Array;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneArrayBuffer.js\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));\n  return result;\n}\nvar cloneArrayBuffer_default = cloneArrayBuffer;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneDataView.js\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nvar cloneDataView_default = cloneDataView;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneRegExp.js\nvar reFlags = /\\w*$/;\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\nvar cloneRegExp_default = cloneRegExp;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneSymbol.js\nvar symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;\nvar symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\nvar cloneSymbol_default = cloneSymbol;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneTypedArray.js\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar cloneTypedArray_default = cloneTypedArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneByTag.js\nvar boolTag2 = \"[object Boolean]\";\nvar dateTag2 = \"[object Date]\";\nvar mapTag3 = \"[object Map]\";\nvar numberTag2 = \"[object Number]\";\nvar regexpTag2 = \"[object RegExp]\";\nvar setTag3 = \"[object Set]\";\nvar stringTag2 = \"[object String]\";\nvar symbolTag2 = \"[object Symbol]\";\nvar arrayBufferTag2 = \"[object ArrayBuffer]\";\nvar dataViewTag3 = \"[object DataView]\";\nvar float32Tag2 = \"[object Float32Array]\";\nvar float64Tag2 = \"[object Float64Array]\";\nvar int8Tag2 = \"[object Int8Array]\";\nvar int16Tag2 = \"[object Int16Array]\";\nvar int32Tag2 = \"[object Int32Array]\";\nvar uint8Tag2 = \"[object Uint8Array]\";\nvar uint8ClampedTag2 = \"[object Uint8ClampedArray]\";\nvar uint16Tag2 = \"[object Uint16Array]\";\nvar uint32Tag2 = \"[object Uint32Array]\";\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag2:\n      return cloneArrayBuffer_default(object);\n    case boolTag2:\n    case dateTag2:\n      return new Ctor(+object);\n    case dataViewTag3:\n      return cloneDataView_default(object, isDeep);\n    case float32Tag2:\n    case float64Tag2:\n    case int8Tag2:\n    case int16Tag2:\n    case int32Tag2:\n    case uint8Tag2:\n    case uint8ClampedTag2:\n    case uint16Tag2:\n    case uint32Tag2:\n      return cloneTypedArray_default(object, isDeep);\n    case mapTag3:\n      return new Ctor();\n    case numberTag2:\n    case stringTag2:\n      return new Ctor(object);\n    case regexpTag2:\n      return cloneRegExp_default(object);\n    case setTag3:\n      return new Ctor();\n    case symbolTag2:\n      return cloneSymbol_default(object);\n  }\n}\nvar initCloneByTag_default = initCloneByTag;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneObject.js\nfunction initCloneObject(object) {\n  return typeof object.constructor == \"function\" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};\n}\nvar initCloneObject_default = initCloneObject;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMap.js\nvar mapTag4 = \"[object Map]\";\nfunction baseIsMap(value) {\n  return isObjectLike_default(value) && getTag_default(value) == mapTag4;\n}\nvar baseIsMap_default = baseIsMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMap.js\nvar nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;\nvar isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;\nvar isMap_default = isMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsSet.js\nvar setTag4 = \"[object Set]\";\nfunction baseIsSet(value) {\n  return isObjectLike_default(value) && getTag_default(value) == setTag4;\n}\nvar baseIsSet_default = baseIsSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSet.js\nvar nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;\nvar isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;\nvar isSet_default = isSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseClone.js\nvar CLONE_DEEP_FLAG = 1;\nvar CLONE_FLAT_FLAG = 2;\nvar CLONE_SYMBOLS_FLAG = 4;\nvar argsTag3 = \"[object Arguments]\";\nvar arrayTag2 = \"[object Array]\";\nvar boolTag3 = \"[object Boolean]\";\nvar dateTag3 = \"[object Date]\";\nvar errorTag2 = \"[object Error]\";\nvar funcTag3 = \"[object Function]\";\nvar genTag2 = \"[object GeneratorFunction]\";\nvar mapTag5 = \"[object Map]\";\nvar numberTag3 = \"[object Number]\";\nvar objectTag3 = \"[object Object]\";\nvar regexpTag3 = \"[object RegExp]\";\nvar setTag5 = \"[object Set]\";\nvar stringTag3 = \"[object String]\";\nvar symbolTag3 = \"[object Symbol]\";\nvar weakMapTag3 = \"[object WeakMap]\";\nvar arrayBufferTag3 = \"[object ArrayBuffer]\";\nvar dataViewTag4 = \"[object DataView]\";\nvar float32Tag3 = \"[object Float32Array]\";\nvar float64Tag3 = \"[object Float64Array]\";\nvar int8Tag3 = \"[object Int8Array]\";\nvar int16Tag3 = \"[object Int16Array]\";\nvar int32Tag3 = \"[object Int32Array]\";\nvar uint8Tag3 = \"[object Uint8Array]\";\nvar uint8ClampedTag3 = \"[object Uint8ClampedArray]\";\nvar uint16Tag3 = \"[object Uint16Array]\";\nvar uint32Tag3 = \"[object Uint32Array]\";\nvar cloneableTags = {};\ncloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag3] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;\ncloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== void 0) {\n    return result;\n  }\n  if (!isObject_default(value)) {\n    return value;\n  }\n  var isArr = isArray_default(value);\n  if (isArr) {\n    result = initCloneArray_default(value);\n    if (!isDeep) {\n      return copyArray_default(value, result);\n    }\n  } else {\n    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;\n    if (isBuffer_default(value)) {\n      return cloneBuffer_default(value, isDeep);\n    }\n    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {\n      result = isFlat || isFunc ? {} : initCloneObject_default(value);\n      if (!isDeep) {\n        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag_default(value, tag, isDeep);\n    }\n  }\n  stack || (stack = new Stack_default());\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  if (isSet_default(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap_default(value)) {\n    value.forEach(function(subValue, key2) {\n      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n    });\n  }\n  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;\n  var props = isArr ? void 0 : keysFunc(value);\n  arrayEach_default(props || value, function(subValue, key2) {\n    if (props) {\n      key2 = subValue;\n      subValue = value[key2];\n    }\n    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n  });\n  return result;\n}\nvar baseClone_default = baseClone;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js\nvar CLONE_SYMBOLS_FLAG2 = 4;\nfunction clone(value) {\n  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);\n}\nvar clone_default = clone;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js\nfunction compact(array) {\n  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar compact_default = compact;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js\nvar HASH_UNDEFINED3 = \"__lodash_hash_undefined__\";\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED3);\n  return this;\n}\nvar setCacheAdd_default = setCacheAdd;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\nvar setCacheHas_default = setCacheHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js\nfunction SetCache(values2) {\n  var index = -1, length = values2 == null ? 0 : values2.length;\n  this.__data__ = new MapCache_default();\n  while (++index < length) {\n    this.add(values2[index]);\n  }\n}\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;\nSetCache.prototype.has = setCacheHas_default;\nvar SetCache_default = SetCache;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js\nfunction arraySome(array, predicate) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar arraySome_default = arraySome;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\nvar cacheHas_default = cacheHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js\nvar COMPARE_PARTIAL_FLAG = 1;\nvar COMPARE_UNORDERED_FLAG = 2;\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;\n  stack.set(array, other);\n  stack.set(other, array);\n  while (++index < arrLength) {\n    var arrValue = array[index], othValue = other[index];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== void 0) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    if (seen) {\n      if (!arraySome_default(other, function(othValue2, othIndex) {\n        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack[\"delete\"](array);\n  stack[\"delete\"](other);\n  return result;\n}\nvar equalArrays_default = equalArrays;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js\nfunction mapToArray(map2) {\n  var index = -1, result = Array(map2.size);\n  map2.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\nvar mapToArray_default = mapToArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js\nfunction setToArray(set) {\n  var index = -1, result = Array(set.size);\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\nvar setToArray_default = setToArray;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js\nvar COMPARE_PARTIAL_FLAG2 = 1;\nvar COMPARE_UNORDERED_FLAG2 = 2;\nvar boolTag4 = \"[object Boolean]\";\nvar dateTag4 = \"[object Date]\";\nvar errorTag3 = \"[object Error]\";\nvar mapTag6 = \"[object Map]\";\nvar numberTag4 = \"[object Number]\";\nvar regexpTag4 = \"[object RegExp]\";\nvar setTag6 = \"[object Set]\";\nvar stringTag4 = \"[object String]\";\nvar symbolTag4 = \"[object Symbol]\";\nvar arrayBufferTag4 = \"[object ArrayBuffer]\";\nvar dataViewTag5 = \"[object DataView]\";\nvar symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;\nvar symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag5:\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n    case arrayBufferTag4:\n      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {\n        return false;\n      }\n      return true;\n    case boolTag4:\n    case dateTag4:\n    case numberTag4:\n      return eq_default(+object, +other);\n    case errorTag3:\n      return object.name == other.name && object.message == other.message;\n    case regexpTag4:\n    case stringTag4:\n      return object == other + \"\";\n    case mapTag6:\n      var convert = mapToArray_default;\n    case setTag6:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;\n      convert || (convert = setToArray_default);\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG2;\n      stack.set(object, other);\n      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack[\"delete\"](object);\n      return result;\n    case symbolTag4:\n      if (symbolValueOf2) {\n        return symbolValueOf2.call(object) == symbolValueOf2.call(other);\n      }\n  }\n  return false;\n}\nvar equalByTag_default = equalByTag;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js\nvar COMPARE_PARTIAL_FLAG3 = 1;\nvar objectProto15 = Object.prototype;\nvar hasOwnProperty12 = objectProto15.hasOwnProperty;\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {\n      return false;\n    }\n  }\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key], othValue = other[key];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n    }\n    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == \"constructor\");\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor, othCtor = other.constructor;\n    if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack[\"delete\"](object);\n  stack[\"delete\"](other);\n  return result;\n}\nvar equalObjects_default = equalObjects;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js\nvar COMPARE_PARTIAL_FLAG4 = 1;\nvar argsTag4 = \"[object Arguments]\";\nvar arrayTag3 = \"[object Array]\";\nvar objectTag4 = \"[object Object]\";\nvar objectProto16 = Object.prototype;\nvar hasOwnProperty13 = objectProto16.hasOwnProperty;\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);\n  objTag = objTag == argsTag4 ? objectTag4 : objTag;\n  othTag = othTag == argsTag4 ? objectTag4 : othTag;\n  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;\n  if (isSameTag && isBuffer_default(object)) {\n    if (!isBuffer_default(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack_default());\n    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {\n    var objIsWrapped = objIsObj && hasOwnProperty13.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, \"__wrapped__\");\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n      stack || (stack = new Stack_default());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack_default());\n  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);\n}\nvar baseIsEqualDeep_default = baseIsEqualDeep;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);\n}\nvar baseIsEqual_default = baseIsEqual;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js\nvar COMPARE_PARTIAL_FLAG5 = 1;\nvar COMPARE_UNORDERED_FLAG3 = 2;\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length, length = index, noCustomizer = !customizer;\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0], objValue = object[key], srcValue = data[1];\n    if (noCustomizer && data[2]) {\n      if (objValue === void 0 && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack_default();\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nvar baseIsMatch_default = baseIsMatch;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js\nfunction isStrictComparable(value) {\n  return value === value && !isObject_default(value);\n}\nvar isStrictComparable_default = isStrictComparable;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js\nfunction getMatchData(object) {\n  var result = keys_default(object), length = result.length;\n  while (length--) {\n    var key = result[length], value = object[key];\n    result[length] = [key, value, isStrictComparable_default(value)];\n  }\n  return result;\n}\nvar getMatchData_default = getMatchData;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n  };\n}\nvar matchesStrictComparable_default = matchesStrictComparable;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js\nfunction baseMatches(source) {\n  var matchData = getMatchData_default(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch_default(object, source, matchData);\n  };\n}\nvar baseMatches_default = baseMatches;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\nvar baseHasIn_default = baseHasIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js\nfunction hasPath(object, path, hasFunc) {\n  path = castPath_default(path, object);\n  var index = -1, length = path.length, result = false;\n  while (++index < length) {\n    var key = toKey_default(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));\n}\nvar hasPath_default = hasPath;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js\nfunction hasIn(object, path) {\n  return object != null && hasPath_default(object, path, baseHasIn_default);\n}\nvar hasIn_default = hasIn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js\nvar COMPARE_PARTIAL_FLAG6 = 1;\nvar COMPARE_UNORDERED_FLAG4 = 2;\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey_default(path) && isStrictComparable_default(srcValue)) {\n    return matchesStrictComparable_default(toKey_default(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get_default(object, path);\n    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);\n  };\n}\nvar baseMatchesProperty_default = baseMatchesProperty;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? void 0 : object[key];\n  };\n}\nvar baseProperty_default = baseProperty;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet_default(object, path);\n  };\n}\nvar basePropertyDeep_default = basePropertyDeep;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js\nfunction property(path) {\n  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);\n}\nvar property_default = property;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js\nfunction baseIteratee(value) {\n  if (typeof value == \"function\") {\n    return value;\n  }\n  if (value == null) {\n    return identity_default;\n  }\n  if (typeof value == \"object\") {\n    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);\n  }\n  return property_default(value);\n}\nvar baseIteratee_default = baseIteratee;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayAggregator.js\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\nvar arrayAggregator_default = arrayAggregator;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\nvar createBaseFor_default = createBaseFor;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js\nvar baseFor = createBaseFor_default();\nvar baseFor_default = baseFor;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor_default(object, iteratee, keys_default);\n}\nvar baseForOwn_default = baseForOwn;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseEach.js\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike_default(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);\n    while (fromRight ? index-- : ++index < length) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\nvar createBaseEach_default = createBaseEach;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEach.js\nvar baseEach = createBaseEach_default(baseForOwn_default);\nvar baseEach_default = baseEach;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAggregator.js\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach_default(collection, function(value, key, collection2) {\n    setter(accumulator, value, iteratee(value), collection2);\n  });\n  return accumulator;\n}\nvar baseAggregator_default = baseAggregator;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAggregator.js\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};\n    return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);\n  };\n}\nvar createAggregator_default = createAggregator;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defaults.js\nvar objectProto17 = Object.prototype;\nvar hasOwnProperty14 = objectProto17.hasOwnProperty;\nvar defaults = baseRest_default(function(object, sources) {\n  object = Object(object);\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : void 0;\n  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn_default(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n      if (value === void 0 || eq_default(value, objectProto17[key]) && !hasOwnProperty14.call(object, key)) {\n        object[key] = source[key];\n      }\n    }\n  }\n  return object;\n});\nvar defaults_default = defaults;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js\nfunction isArrayLikeObject(value) {\n  return isObjectLike_default(value) && isArrayLike_default(value);\n}\nvar isArrayLikeObject_default = isArrayLikeObject;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludesWith.js\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar arrayIncludesWith_default = arrayIncludesWith;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseDifference.js\nvar LARGE_ARRAY_SIZE2 = 200;\nfunction baseDifference(array, values2, iteratee, comparator) {\n  var index = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result = [], valuesLength = values2.length;\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values2 = arrayMap_default(values2, baseUnary_default(iteratee));\n  }\n  if (comparator) {\n    includes2 = arrayIncludesWith_default;\n    isCommon = false;\n  } else if (values2.length >= LARGE_ARRAY_SIZE2) {\n    includes2 = cacheHas_default;\n    isCommon = false;\n    values2 = new SetCache_default(values2);\n  }\n  outer:\n    while (++index < length) {\n      var value = array[index], computed = iteratee == null ? value : iteratee(value);\n      value = comparator || value !== 0 ? value : 0;\n      if (isCommon && computed === computed) {\n        var valuesIndex = valuesLength;\n        while (valuesIndex--) {\n          if (values2[valuesIndex] === computed) {\n            continue outer;\n          }\n        }\n        result.push(value);\n      } else if (!includes2(values2, computed, comparator)) {\n        result.push(value);\n      }\n    }\n  return result;\n}\nvar baseDifference_default = baseDifference;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/difference.js\nvar difference = baseRest_default(function(array, values2) {\n  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];\n});\nvar difference_default = difference;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/last.js\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : void 0;\n}\nvar last_default = last;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/drop.js\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = guard || n === void 0 ? 1 : toInteger_default(n);\n  return baseSlice_default(array, n < 0 ? 0 : n, length);\n}\nvar drop_default = drop;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/dropRight.js\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = guard || n === void 0 ? 1 : toInteger_default(n);\n  n = length - n;\n  return baseSlice_default(array, 0, n < 0 ? 0 : n);\n}\nvar dropRight_default = dropRight;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castFunction.js\nfunction castFunction(value) {\n  return typeof value == \"function\" ? value : identity_default;\n}\nvar castFunction_default = castFunction;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forEach.js\nfunction forEach(collection, iteratee) {\n  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;\n  return func(collection, castFunction_default(iteratee));\n}\nvar forEach_default = forEach;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEvery.js\nfunction arrayEvery(array, predicate) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\nvar arrayEvery_default = arrayEvery;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEvery.js\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach_default(collection, function(value, index, collection2) {\n    result = !!predicate(value, index, collection2);\n    return result;\n  });\n  return result;\n}\nvar baseEvery_default = baseEvery;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/every.js\nfunction every(collection, predicate, guard) {\n  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;\n  if (guard && isIterateeCall_default(collection, predicate, guard)) {\n    predicate = void 0;\n  }\n  return func(collection, baseIteratee_default(predicate, 3));\n}\nvar every_default = every;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFilter.js\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach_default(collection, function(value, index, collection2) {\n    if (predicate(value, index, collection2)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\nvar baseFilter_default = baseFilter;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/filter.js\nfunction filter(collection, predicate) {\n  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;\n  return func(collection, baseIteratee_default(predicate, 3));\n}\nvar filter_default = filter;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createFind.js\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike_default(collection)) {\n      var iteratee = baseIteratee_default(predicate, 3);\n      collection = keys_default(collection);\n      predicate = function(key) {\n        return iteratee(iterable[key], key, iterable);\n      };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;\n  };\n}\nvar createFind_default = createFind;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findIndex.js\nvar nativeMax2 = Math.max;\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);\n  if (index < 0) {\n    index = nativeMax2(length + index, 0);\n  }\n  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);\n}\nvar findIndex_default = findIndex;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/find.js\nvar find = createFind_default(findIndex_default);\nvar find_default = find;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js\nfunction head(array) {\n  return array && array.length ? array[0] : void 0;\n}\nvar head_default = head;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMap.js\nfunction baseMap(collection, iteratee) {\n  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];\n  baseEach_default(collection, function(value, key, collection2) {\n    result[++index] = iteratee(value, key, collection2);\n  });\n  return result;\n}\nvar baseMap_default = baseMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/map.js\nfunction map(collection, iteratee) {\n  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;\n  return func(collection, baseIteratee_default(iteratee, 3));\n}\nvar map_default = map;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMap.js\nfunction flatMap(collection, iteratee) {\n  return baseFlatten_default(map_default(collection, iteratee), 1);\n}\nvar flatMap_default = flatMap;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/groupBy.js\nvar objectProto18 = Object.prototype;\nvar hasOwnProperty15 = objectProto18.hasOwnProperty;\nvar groupBy = createAggregator_default(function(result, value, key) {\n  if (hasOwnProperty15.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue_default(result, key, [value]);\n  }\n});\nvar groupBy_default = groupBy;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHas.js\nvar objectProto19 = Object.prototype;\nvar hasOwnProperty16 = objectProto19.hasOwnProperty;\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty16.call(object, key);\n}\nvar baseHas_default = baseHas;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/has.js\nfunction has(object, path) {\n  return object != null && hasPath_default(object, path, baseHas_default);\n}\nvar has_default = has;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isString.js\nvar stringTag5 = \"[object String]\";\nfunction isString(value) {\n  return typeof value == \"string\" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;\n}\nvar isString_default = isString;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseValues.js\nfunction baseValues(object, props) {\n  return arrayMap_default(props, function(key) {\n    return object[key];\n  });\n}\nvar baseValues_default = baseValues;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/values.js\nfunction values(object) {\n  return object == null ? [] : baseValues_default(object, keys_default(object));\n}\nvar values_default = values;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/includes.js\nvar nativeMax3 = Math.max;\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike_default(collection) ? collection : values_default(collection);\n  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax3(length + fromIndex, 0);\n  }\n  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;\n}\nvar includes_default = includes;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/indexOf.js\nvar nativeMax4 = Math.max;\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);\n  if (index < 0) {\n    index = nativeMax4(length + index, 0);\n  }\n  return baseIndexOf_default(array, value, index);\n}\nvar indexOf_default = indexOf;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js\nvar mapTag7 = \"[object Map]\";\nvar setTag7 = \"[object Set]\";\nvar objectProto20 = Object.prototype;\nvar hasOwnProperty17 = objectProto20.hasOwnProperty;\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {\n    return !value.length;\n  }\n  var tag = getTag_default(value);\n  if (tag == mapTag7 || tag == setTag7) {\n    return !value.size;\n  }\n  if (isPrototype_default(value)) {\n    return !baseKeys_default(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty17.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nvar isEmpty_default = isEmpty;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsRegExp.js\nvar regexpTag5 = \"[object RegExp]\";\nfunction baseIsRegExp(value) {\n  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;\n}\nvar baseIsRegExp_default = baseIsRegExp;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isRegExp.js\nvar nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;\nvar isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;\nvar isRegExp_default = isRegExp;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js\nfunction isUndefined(value) {\n  return value === void 0;\n}\nvar isUndefined_default = isUndefined;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/negate.js\nvar FUNC_ERROR_TEXT2 = \"Expected a function\";\nfunction negate(predicate) {\n  if (typeof predicate != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT2);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0:\n        return !predicate.call(this);\n      case 1:\n        return !predicate.call(this, args[0]);\n      case 2:\n        return !predicate.call(this, args[0], args[1]);\n      case 3:\n        return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\nvar negate_default = negate;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSet.js\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject_default(object)) {\n    return object;\n  }\n  path = castPath_default(path, object);\n  var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n  while (nested != null && ++index < length) {\n    var key = toKey_default(path[index]), newValue = value;\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      return object;\n    }\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : void 0;\n      if (newValue === void 0) {\n        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};\n      }\n    }\n    assignValue_default(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\nvar baseSet_default = baseSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePickBy.js\nfunction basePickBy(object, paths, predicate) {\n  var index = -1, length = paths.length, result = {};\n  while (++index < length) {\n    var path = paths[index], value = baseGet_default(object, path);\n    if (predicate(value, path)) {\n      baseSet_default(result, castPath_default(path, object), value);\n    }\n  }\n  return result;\n}\nvar basePickBy_default = basePickBy;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pickBy.js\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee_default(predicate);\n  return basePickBy_default(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\nvar pickBy_default = pickBy;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseReduce.js\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection2) {\n    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n  });\n  return accumulator;\n}\nvar baseReduce_default = baseReduce;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reduce.js\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;\n  return func(collection, baseIteratee_default(iteratee, 4), accumulator, initAccum, baseEach_default);\n}\nvar reduce_default = reduce;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reject.js\nfunction reject(collection, predicate) {\n  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;\n  return func(collection, negate_default(baseIteratee_default(predicate, 3)));\n}\nvar reject_default = reject;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSome.js\nfunction baseSome(collection, predicate) {\n  var result;\n  baseEach_default(collection, function(value, index, collection2) {\n    result = predicate(value, index, collection2);\n    return !result;\n  });\n  return !!result;\n}\nvar baseSome_default = baseSome;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/some.js\nfunction some(collection, predicate, guard) {\n  var func = isArray_default(collection) ? arraySome_default : baseSome_default;\n  if (guard && isIterateeCall_default(collection, predicate, guard)) {\n    predicate = void 0;\n  }\n  return func(collection, baseIteratee_default(predicate, 3));\n}\nvar some_default = some;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createSet.js\nvar INFINITY4 = 1 / 0;\nvar createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {\n  return new Set_default(values2);\n};\nvar createSet_default = createSet;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUniq.js\nvar LARGE_ARRAY_SIZE3 = 200;\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;\n  if (comparator) {\n    isCommon = false;\n    includes2 = arrayIncludesWith_default;\n  } else if (length >= LARGE_ARRAY_SIZE3) {\n    var set = iteratee ? null : createSet_default(array);\n    if (set) {\n      return setToArray_default(set);\n    }\n    isCommon = false;\n    includes2 = cacheHas_default;\n    seen = new SetCache_default();\n  } else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n    while (++index < length) {\n      var value = array[index], computed = iteratee ? iteratee(value) : value;\n      value = comparator || value !== 0 ? value : 0;\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length;\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer;\n          }\n        }\n        if (iteratee) {\n          seen.push(computed);\n        }\n        result.push(value);\n      } else if (!includes2(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n  return result;\n}\nvar baseUniq_default = baseUniq;\n\n// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js\nfunction uniq(array) {\n  return array && array.length ? baseUniq_default(array) : [];\n}\nvar uniq_default = uniq;\n\n// ../utils/lib/src/print.js\nfunction PRINT_ERROR(msg) {\n  if (console && console.error) {\n    console.error(`Error: ${msg}`);\n  }\n}\nfunction PRINT_WARNING(msg) {\n  if (console && console.warn) {\n    console.warn(`Warning: ${msg}`);\n  }\n}\n\n// ../utils/lib/src/timer.js\nfunction timer(func) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  const val = func();\n  const end = (/* @__PURE__ */ new Date()).getTime();\n  const total = end - start;\n  return { time: total, value: val };\n}\n\n// ../utils/lib/src/to-fast-properties.js\nfunction toFastProperties(toBecomeFast) {\n  function FakeConstructor() {\n  }\n  FakeConstructor.prototype = toBecomeFast;\n  const fakeInstance = new FakeConstructor();\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n  fakeAccess();\n  fakeAccess();\n  if (true)\n    return toBecomeFast;\n  (0, eval)(toBecomeFast);\n}\n\n// ../gast/lib/src/model.js\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\nfunction hasTokenLabel(obj) {\n  return isString_default(obj.LABEL) && obj.LABEL !== \"\";\n}\nvar AbstractProduction = class {\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(_definition) {\n    this._definition = _definition;\n  }\n  accept(visitor) {\n    visitor.visit(this);\n    forEach_default(this.definition, (prod) => {\n      prod.accept(visitor);\n    });\n  }\n};\nvar NonTerminal = class extends AbstractProduction {\n  constructor(options) {\n    super([]);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n  set definition(definition) {\n  }\n  get definition() {\n    if (this.referencedRule !== void 0) {\n      return this.referencedRule.definition;\n    }\n    return [];\n  }\n  accept(visitor) {\n    visitor.visit(this);\n  }\n};\nvar Rule = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.orgText = \"\";\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Alternative = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.ignoreAmbiguities = false;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Option = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionMandatory = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionMandatoryWithSeparator = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Repetition = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionWithSeparator = class extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Alternation = class extends AbstractProduction {\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    this.ignoreAmbiguities = false;\n    this.hasPredicates = false;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Terminal = class {\n  constructor(options) {\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n  accept(visitor) {\n    visitor.visit(this);\n  }\n};\nfunction serializeGrammar(topRules) {\n  return map_default(topRules, serializeProduction);\n}\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return map_default(definition, serializeProduction);\n  }\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n    if (isString_default(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n    if (isString_default(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n    const pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp_default(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\n// ../gast/lib/src/visitor.js\nvar GAstVisitor = class {\n  visit(node) {\n    const nodeAny = node;\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny);\n      case Alternative:\n        return this.visitAlternative(nodeAny);\n      case Option:\n        return this.visitOption(nodeAny);\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny);\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny);\n      case Repetition:\n        return this.visitRepetition(nodeAny);\n      case Alternation:\n        return this.visitAlternation(nodeAny);\n      case Terminal:\n        return this.visitTerminal(nodeAny);\n      case Rule:\n        return this.visitRule(nodeAny);\n      default:\n        throw Error(\"non exhaustive match\");\n    }\n  }\n  /* c8 ignore next */\n  visitNonTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitAlternative(node) {\n  }\n  /* c8 ignore next */\n  visitOption(node) {\n  }\n  /* c8 ignore next */\n  visitRepetition(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionMandatory(node) {\n  }\n  /* c8 ignore next 3 */\n  visitRepetitionMandatoryWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitAlternation(node) {\n  }\n  /* c8 ignore next */\n  visitTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitRule(node) {\n  }\n};\n\n// ../gast/lib/src/helpers.js\nfunction isSequenceProd(prod) {\n  return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;\n}\nfunction isOptionalProd(prod, alreadyVisited = []) {\n  const isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n  if (prod instanceof Alternation) {\n    return some_default(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof NonTerminal && includes_default(alreadyVisited, prod)) {\n    return false;\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return every_default(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else {\n    return false;\n  }\n}\nfunction isBranchingProd(prod) {\n  return prod instanceof Alternation;\n}\nfunction getProductionDslName(prod) {\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\n// lib/src/parse/grammar/rest.js\nvar RestWalker = class {\n  walk(prod, prevRest = []) {\n    forEach_default(prod.definition, (subProd, index) => {\n      const currRest = drop_default(prod.definition, index + 1);\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n  }\n  walkFlat(flatProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    const fullAtLeastOneRest = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    const fullManyRest = [\n      new Option({ definition: manyProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  }\n  walkOr(orProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    forEach_default(orProd.definition, (alt) => {\n      const prodWrapper = new Alternative({ definition: [alt] });\n      this.walk(prodWrapper, fullOrRest);\n    });\n  }\n};\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator })\n      ].concat(repSepProd.definition)\n    })\n  ];\n  const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}\n\n// lib/src/parse/grammar/first.js\nfunction first(prod) {\n  if (prod instanceof NonTerminal) {\n    return first(prod.referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction firstForSequence(prod) {\n  let firstSet = [];\n  const seq = prod.definition;\n  let nextSubProdIdx = 0;\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  let currSubProd;\n  let isLastInnerProdOptional = true;\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return uniq_default(firstSet);\n}\nfunction firstForBranching(prod) {\n  const allAlternativesFirsts = map_default(prod.definition, (innerProd) => {\n    return first(innerProd);\n  });\n  return uniq_default(flatten_default(allAlternativesFirsts));\n}\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\n\n// lib/src/parse/constants.js\nvar IN = \"_~IN~_\";\n\n// lib/src/parse/grammar/follow.js\nvar ResyncFollowsWalker = class extends RestWalker {\n  constructor(topProd) {\n    super();\n    this.topProd = topProd;\n    this.follows = {};\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.follows;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n    const fullRest = currRest.concat(prevRest);\n    const restProd = new Alternative({ definition: fullRest });\n    const t_in_topProd_follows = first(restProd);\n    this.follows[followName] = t_in_topProd_follows;\n  }\n};\nfunction computeAllProdsFollows(topProductions) {\n  const reSyncFollows = {};\n  forEach_default(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n    assign_default(reSyncFollows, currRefsFollow);\n  });\n  return reSyncFollows;\n}\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n  return inner.name + occurenceInParent + IN;\n}\n\n// ../regexp-to-ast/lib/src/utils.js\nfunction cc(char) {\n  return char.charCodeAt(0);\n}\nfunction insertToSet(item, set) {\n  if (Array.isArray(item)) {\n    item.forEach(function(subItem) {\n      set.push(subItem);\n    });\n  } else {\n    set.push(item);\n  }\n}\nfunction addFlag(flagObj, flagKey) {\n  if (flagObj[flagKey] === true) {\n    throw \"duplicate flag \" + flagKey;\n  }\n  const x = flagObj[flagKey];\n  flagObj[flagKey] = true;\n}\nfunction ASSERT_EXISTS(obj) {\n  if (obj === void 0) {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  return true;\n}\nfunction ASSERT_NEVER_REACH_HERE() {\n  throw Error(\"Internal Error - Should never get here!\");\n}\nfunction isCharacter(obj) {\n  return obj[\"type\"] === \"Character\";\n}\n\n// ../regexp-to-ast/lib/src/character-classes.js\nvar digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n  digitsCharCodes.push(i);\n}\nvar wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n  wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n  wordCharCodes.push(i);\n}\nvar whitespaceCodes = [\n  cc(\" \"),\n  cc(\"\\f\"),\n  cc(\"\\n\"),\n  cc(\"\\r\"),\n  cc(\"\t\"),\n  cc(\"\\v\"),\n  cc(\"\t\"),\n  cc(\"\\xA0\"),\n  cc(\"\\u1680\"),\n  cc(\"\\u2000\"),\n  cc(\"\\u2001\"),\n  cc(\"\\u2002\"),\n  cc(\"\\u2003\"),\n  cc(\"\\u2004\"),\n  cc(\"\\u2005\"),\n  cc(\"\\u2006\"),\n  cc(\"\\u2007\"),\n  cc(\"\\u2008\"),\n  cc(\"\\u2009\"),\n  cc(\"\\u200A\"),\n  cc(\"\\u2028\"),\n  cc(\"\\u2029\"),\n  cc(\"\\u202F\"),\n  cc(\"\\u205F\"),\n  cc(\"\\u3000\"),\n  cc(\"\\uFEFF\")\n];\n\n// ../regexp-to-ast/lib/src/regexp-parser.js\nvar hexDigitPattern = /[0-9a-fA-F]/;\nvar decimalPattern = /[0-9]/;\nvar decimalPatternNoZero = /[1-9]/;\nvar RegExpParser = class {\n  constructor() {\n    this.idx = 0;\n    this.input = \"\";\n    this.groupIdx = 0;\n  }\n  saveState() {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  }\n  restoreState(newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  }\n  pattern(input) {\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    const value = this.disjunction();\n    this.consumeChar(\"/\");\n    const flags = {\n      type: \"Flags\",\n      loc: { begin: this.idx, end: input.length },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags,\n      value,\n      loc: this.loc(0)\n    };\n  }\n  disjunction() {\n    const alts = [];\n    const begin = this.idx;\n    alts.push(this.alternative());\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n  }\n  alternative() {\n    const terms = [];\n    const begin = this.idx;\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n  }\n  term() {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  }\n  assertion() {\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n      case \"$\":\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        }\n        throw Error(\"Invalid Assertion Escape\");\n      case \"(\":\n        this.consumeChar(\"?\");\n        let type;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n        const disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  quantifier(isBacktracking = false) {\n    let range = void 0;\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n      case \"{\":\n        const atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast,\n              atMost: atLeast\n            };\n            break;\n          case \",\":\n            let atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast,\n                atMost\n              };\n            } else {\n              range = {\n                atLeast,\n                atMost: Infinity\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        if (isBacktracking === true && range === void 0) {\n          return void 0;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n    if (isBacktracking === true && range === void 0) {\n      return void 0;\n    }\n    if (ASSERT_EXISTS(range)) {\n      if (this.peekChar(0) === \"?\") {\n        this.consumeChar(\"?\");\n        range.greedy = false;\n      } else {\n        range.greedy = true;\n      }\n      range.type = \"Quantifier\";\n      range.loc = this.loc(begin);\n      return range;\n    }\n  }\n  atom() {\n    let atom;\n    const begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n      case \"[\":\n        atom = this.characterClass();\n        break;\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n    if (atom === void 0 && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n    if (ASSERT_EXISTS(atom)) {\n      atom.loc = this.loc(begin);\n      if (this.isQuantifier()) {\n        atom.quantifier = this.quantifier();\n      }\n      return atom;\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  dotAll() {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  }\n  atomEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  decimalEscapeAtom() {\n    const value = this.positiveInteger();\n    return { type: \"GroupBackReference\", value };\n  }\n  characterClassEscape() {\n    let set;\n    let complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n    if (ASSERT_EXISTS(set)) {\n      return { type: \"Set\", value: set, complement };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  controlEscapeAtom() {\n    let escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n    if (ASSERT_EXISTS(escapeCode)) {\n      return { type: \"Character\", value: escapeCode };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  controlLetterEscapeAtom() {\n    this.consumeChar(\"c\");\n    const letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return { type: \"Character\", value: letterCode };\n  }\n  nulCharacterAtom() {\n    this.consumeChar(\"0\");\n    return { type: \"Character\", value: cc(\"\\0\") };\n  }\n  hexEscapeSequenceAtom() {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  }\n  regExpUnicodeEscapeSequenceAtom() {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  }\n  identityEscapeAtom() {\n    const escapedChar = this.popChar();\n    return { type: \"Character\", value: cc(escapedChar) };\n  }\n  classPatternCharacterAtom() {\n    switch (this.peekChar()) {\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n      case \"\\\\\":\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        const nextChar = this.popChar();\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  characterClass() {\n    const set = [];\n    let complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n    while (this.isClassAtom()) {\n      const from = this.classAtom();\n      const isFromSingleChar = from.type === \"Character\";\n      if (isCharacter(from) && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        const to = this.classAtom();\n        const isToSingleChar = to.type === \"Character\";\n        if (isCharacter(to)) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({ from: from.value, to: to.value });\n        } else {\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n    this.consumeChar(\"]\");\n    return { type: \"Set\", complement, value: set };\n  }\n  classAtom() {\n    switch (this.peekChar()) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  }\n  classEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"b\":\n        this.consumeChar(\"b\");\n        return { type: \"Character\", value: cc(\"\\b\") };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  group() {\n    let capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    const value = this.disjunction();\n    this.consumeChar(\")\");\n    const groupAst = {\n      type: \"Group\",\n      capturing,\n      value\n    };\n    if (capturing) {\n      groupAst[\"idx\"] = this.groupIdx;\n    }\n    return groupAst;\n  }\n  positiveInteger() {\n    let number = this.popChar();\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  integerIncludingZero() {\n    let number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  patternCharacter() {\n    const nextChar = this.popChar();\n    switch (nextChar) {\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n        throw Error(\"TBD\");\n      default:\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  isRegExpFlag() {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isRangeDash() {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  }\n  isDigit() {\n    return decimalPattern.test(this.peekChar(0));\n  }\n  isClassAtom(howMuch = 0) {\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  isTerm() {\n    return this.isAtom() || this.isAssertion();\n  }\n  isAtom() {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\":\n      case \"[\":\n      case \"(\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isAssertion() {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n      default:\n        return false;\n    }\n  }\n  isQuantifier() {\n    const prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== void 0;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  }\n  isPatternCharacter() {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  parseHexDigits(howMany) {\n    let hexString = \"\";\n    for (let i = 0; i < howMany; i++) {\n      const hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    const charCode = parseInt(hexString, 16);\n    return { type: \"Character\", value: charCode };\n  }\n  peekChar(howMuch = 0) {\n    return this.input[this.idx + howMuch];\n  }\n  popChar() {\n    const nextChar = this.peekChar(0);\n    this.consumeChar(void 0);\n    return nextChar;\n  }\n  consumeChar(char) {\n    if (char !== void 0 && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  }\n  loc(begin) {\n    return { begin, end: this.idx };\n  }\n};\n\n// ../regexp-to-ast/lib/src/base-regexp-visitor.js\nvar BaseRegExpVisitor = class {\n  visitChildren(node) {\n    for (const key in node) {\n      const child = node[key];\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== void 0) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach((subChild) => {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  }\n  visit(node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n    this.visitChildren(node);\n  }\n  visitPattern(node) {\n  }\n  visitFlags(node) {\n  }\n  visitDisjunction(node) {\n  }\n  visitAlternative(node) {\n  }\n  // Assertion\n  visitStartAnchor(node) {\n  }\n  visitEndAnchor(node) {\n  }\n  visitWordBoundary(node) {\n  }\n  visitNonWordBoundary(node) {\n  }\n  visitLookahead(node) {\n  }\n  visitNegativeLookahead(node) {\n  }\n  // atoms\n  visitCharacter(node) {\n  }\n  visitSet(node) {\n  }\n  visitGroup(node) {\n  }\n  visitGroupBackReference(node) {\n  }\n  visitQuantifier(node) {\n  }\n};\n\n// lib/src/scan/reg_exp_parser.js\nvar regExpAstCache = {};\nvar regExpParser = new RegExpParser();\nfunction getRegExpAst(regExp) {\n  const regExpStr = regExp.toString();\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr];\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr);\n    regExpAstCache[regExpStr] = regExpAst;\n    return regExpAst;\n  }\n}\nfunction clearRegExpParserCache() {\n  regExpAstCache = {};\n}\n\n// lib/src/scan/reg_exp.js\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nvar failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n  try {\n    const ast = getRegExpAst(regExp);\n    const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(`${failedOptimizationPrefixMsg}\tUnable to optimize: < ${regExp.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);\n      }\n    } else {\n      let msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(`${failedOptimizationPrefixMsg}\n\tFailed parsing: < ${regExp.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);\n    }\n  }\n  return [];\n}\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      const terms = ast.value;\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i];\n        switch (term.type) {\n          case \"EndAnchor\":\n          case \"GroupBackReference\":\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        const atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach_default(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                const range = code;\n                if (ignoreCase === true) {\n                  for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } else {\n                  for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    const maxUnOptVal = range.to;\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        const isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          atom.type === \"Group\" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n          atom.type !== \"Group\" && isOptionalQuantifier === false\n        ) {\n          break;\n        }\n      }\n      break;\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  return values_default(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  const char = String.fromCharCode(code);\n  const upperChar = char.toUpperCase();\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    const lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return find_default(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes_default(targetCharCodes, codeOrRange);\n    } else {\n      const range = codeOrRange;\n      return find_default(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== void 0;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  const quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray_default(ast.value) ? every_default(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = class extends BaseRegExpVisitor {\n  constructor(targetCharCodes) {\n    super();\n    this.targetCharCodes = targetCharCodes;\n    this.found = false;\n  }\n  visitChildren(node) {\n    if (this.found === true) {\n      return;\n    }\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    super.visitChildren(node);\n  }\n  visitCharacter(node) {\n    if (includes_default(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  }\n  visitSet(node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === void 0) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== void 0) {\n        this.found = true;\n      }\n    }\n  }\n};\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern);\n    const charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find_default(pattern, (char) => {\n      return includes_default(charCodes, char.charCodeAt(0));\n    }) !== void 0;\n  }\n}\n\n// lib/src/scan/lexer.js\nvar PATTERN = \"PATTERN\";\nvar DEFAULT_MODE = \"defaultMode\";\nvar MODES = \"modes\";\nvar SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction analyzeTokenTypes(tokenTypes, options) {\n  options = defaults_default(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg, action) => action()\n  });\n  const tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap();\n  });\n  let onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject_default(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  let hasCustom = false;\n  let allTransformedPatterns;\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false;\n    allTransformedPatterns = map_default(onlyRelevantTypes, (currType) => {\n      const currPattern = currType[PATTERN];\n      if (isRegExp_default(currPattern)) {\n        const regExpSource = currPattern.source;\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !includes_default([\n          \"d\",\n          \"D\",\n          \"s\",\n          \"S\",\n          \"t\",\n          \"r\",\n          \"n\",\n          \"t\",\n          \"0\",\n          \"c\",\n          \"b\",\n          \"B\",\n          \"f\",\n          \"v\",\n          \"w\",\n          \"W\"\n        ], regExpSource[1])) {\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction_default(currPattern)) {\n        hasCustom = true;\n        return { exec: currPattern };\n      } else if (typeof currPattern === \"object\") {\n        hasCustom = true;\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          const wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  let patternIdxToType;\n  let patternIdxToGroup;\n  let patternIdxToLongerAltIdxArr;\n  let patternIdxToPushMode;\n  let patternIdxToPopMode;\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map_default(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n    patternIdxToGroup = map_default(onlyRelevantTypes, (clazz) => {\n      const groupName = clazz.GROUP;\n      if (groupName === Lexer.SKIPPED) {\n        return void 0;\n      } else if (isString_default(groupName)) {\n        return groupName;\n      } else if (isUndefined_default(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdxArr = map_default(onlyRelevantTypes, (clazz) => {\n      const longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        const longerAltIdxArr = isArray_default(longerAltType) ? map_default(longerAltType, (type) => indexOf_default(onlyRelevantTypes, type)) : [indexOf_default(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n    patternIdxToPushMode = map_default(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n    patternIdxToPopMode = map_default(onlyRelevantTypes, (clazz) => has_default(clazz, \"POP_MODE\"));\n  });\n  let patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => false);\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => {\n        if (has_default(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n        }\n      });\n    }\n  });\n  let patternIdxToIsCustom;\n  let patternIdxToShort;\n  let emptyGroups;\n  let patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map_default(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map_default(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce_default(onlyRelevantTypes, (acc, clazz) => {\n      const groupName = clazz.GROUP;\n      if (isString_default(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = map_default(allTransformedPatterns, (x, idx) => {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdxArr[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  let canBeOptimized = true;\n  let charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce_default(onlyRelevantTypes, (result, currTokType, idx) => {\n        if (typeof currTokType.PATTERN === \"string\") {\n          const charCode = currTokType.PATTERN.charCodeAt(0);\n          const optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray_default(currTokType.START_CHARS_HINT)) {\n          let lastOptimizedIdx;\n          forEach_default(currTokType.START_CHARS_HINT, (charOrInt) => {\n            const charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            if (lastOptimizedIdx !== currOptimizedIdx) {\n              lastOptimizedIdx = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp_default(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(`${failedOptimizationPrefixMsg}\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);\n            }\n          } else {\n            const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            if (isEmpty_default(optimizedCodes)) {\n              canBeOptimized = false;\n            }\n            forEach_default(optimizedCodes, (code) => {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  return {\n    emptyGroups,\n    patternIdxToConfig,\n    charCodeToPatternIdxToConfig,\n    hasCustom,\n    canBeOptimized\n  };\n}\nfunction validatePatterns(tokenTypes, validModesNames) {\n  let errors = [];\n  const missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  const invalidResult = findInvalidPatterns(missingResult.valid);\n  const validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n  let errors = [];\n  const withRegExpPatterns = filter_default(tokenTypes, (currTokType) => isRegExp_default(currTokType[PATTERN]));\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n  const tokenTypesWithMissingPattern = filter_default(tokenTypes, (currType) => {\n    return !has_default(currType, PATTERN);\n  });\n  const errors = map_default(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference_default(tokenTypes, tokenTypesWithMissingPattern);\n  return { errors, valid };\n}\nfunction findInvalidPatterns(tokenTypes) {\n  const tokenTypesWithInvalidPattern = filter_default(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return !isRegExp_default(pattern) && !isFunction_default(pattern) && !has_default(pattern, \"exec\") && !isString_default(pattern);\n  });\n  const errors = map_default(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference_default(tokenTypes, tokenTypesWithInvalidPattern);\n  return { errors, valid };\n}\nvar end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitEndAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      return end_of_input.test(pattern.source);\n    }\n  });\n  const errors = map_default(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findEmptyMatchRegExps(tokenTypes) {\n  const matchesEmptyString = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    return pattern.test(\"\");\n  });\n  const errors = map_default(matchesEmptyString, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitStartAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      return start_of_input.test(pattern.source);\n    }\n  });\n  const errors = map_default(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findUnsupportedFlags(tokenTypes) {\n  const invalidFlags = filter_default(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  const errors = map_default(invalidFlags, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findDuplicatePatterns(tokenTypes) {\n  const found = [];\n  let identicalPatterns = map_default(tokenTypes, (outerType) => {\n    return reduce_default(tokenTypes, (result, innerType) => {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !includes_default(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact_default(identicalPatterns);\n  const duplicatePatterns = filter_default(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1;\n  });\n  const errors = map_default(duplicatePatterns, (setOfIdentical) => {\n    const tokenTypeNames = map_default(setOfIdentical, (currType) => {\n      return currType.name;\n    });\n    const dupPatternSrc = head_default(setOfIdentical).PATTERN;\n    return {\n      message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nfunction findInvalidGroupType(tokenTypes) {\n  const invalidTypes = filter_default(tokenTypes, (clazz) => {\n    if (!has_default(clazz, \"GROUP\")) {\n      return false;\n    }\n    const group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString_default(group);\n  });\n  const errors = map_default(invalidTypes, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n  const invalidModes = filter_default(tokenTypes, (clazz) => {\n    return clazz.PUSH_MODE !== void 0 && !includes_default(validModes, clazz.PUSH_MODE);\n  });\n  const errors = map_default(invalidModes, (tokType) => {\n    const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nfunction findUnreachablePatterns(tokenTypes) {\n  const errors = [];\n  const canBeTested = reduce_default(tokenTypes, (result, tokType, idx) => {\n    const pattern = tokType.PATTERN;\n    if (pattern === Lexer.NA) {\n      return result;\n    }\n    if (isString_default(pattern)) {\n      result.push({ str: pattern, idx, tokenType: tokType });\n    } else if (isRegExp_default(pattern) && noMetaChar(pattern)) {\n      result.push({ str: pattern.source, idx, tokenType: tokType });\n    }\n    return result;\n  }, []);\n  forEach_default(tokenTypes, (tokType, testIdx) => {\n    forEach_default(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg = `Token: ->${tokenType.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction testTokenType(str, pattern) {\n  if (isRegExp_default(pattern)) {\n    const regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction_default(pattern)) {\n    return pattern(str, 0, [], {});\n  } else if (has_default(pattern, \"exec\")) {\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction noMetaChar(regExp) {\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ];\n  return find_default(metaChars, (char) => regExp.source.indexOf(char) !== -1) === void 0;\n}\nfunction addStartOfInput(pattern) {\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\n  return new RegExp(`^(?:${pattern.source})`, flags);\n}\nfunction addStickyFlag(pattern) {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  return new RegExp(`${pattern.source}`, flags);\n}\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const errors = [];\n  if (!has_default(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!has_default(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if (has_default(lexerDefinition, MODES) && has_default(lexerDefinition, DEFAULT_MODE) && !has_default(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if (has_default(lexerDefinition, MODES)) {\n    forEach_default(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach_default(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined_default(currTokType)) {\n          errors.push({\n            message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        } else if (has_default(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray_default(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n          forEach_default(longerAlt, (currLongerAlt) => {\n            if (!isUndefined_default(currLongerAlt) && !includes_default(currModeValue, currLongerAlt)) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const warnings = [];\n  let hasAnyLineBreak = false;\n  const allTokenTypes = compact_default(flatten_default(values_default(lexerDefinition.modes)));\n  const concreteTokenTypes = reject_default(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach_default(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        if (has_default(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\nfunction cloneEmptyGroups(emptyGroups) {\n  const clonedResult = {};\n  const groupKeys = keys_default(emptyGroups);\n  forEach_default(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey];\n    if (isArray_default(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\nfunction isCustomPattern(tokenType) {\n  const pattern = tokenType.PATTERN;\n  if (isRegExp_default(pattern)) {\n    return false;\n  } else if (isFunction_default(pattern)) {\n    return true;\n  } else if (has_default(pattern, \"exec\")) {\n    return true;\n  } else if (isString_default(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction isShortPattern(pattern) {\n  if (isString_default(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\nvar LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function(text) {\n    const len = text.length;\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has_default(tokType, \"LINE_BREAKS\")) {\n    return false;\n  } else {\n    if (isRegExp_default(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if (isString_default(tokType.PATTERN)) {\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return `Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${tokType.name}> Token Type\n\t Root cause: ${details.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${tokType.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getCharCodes(charsOrCodes) {\n  const charCodes = map_default(charsOrCodes, (numOrString) => {\n    if (isString_default(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\nfunction addToMapOfArrays(map2, key, value) {\n  if (map2[key] === void 0) {\n    map2[key] = [value];\n  } else {\n    map2[key].push(value);\n  }\n}\nvar minOptimizationVal = 256;\nvar charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty_default(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}\n\n// lib/src/scan/tokens.js\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  const instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nvar tokenShortNameIdx = 1;\nvar tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  const tokenTypesAndParents = expandCategories(tokenTypes);\n  assignTokenDefaultProps(tokenTypesAndParents);\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach_default(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nfunction expandCategories(tokenTypes) {\n  let result = clone_default(tokenTypes);\n  let categories = tokenTypes;\n  let searching = true;\n  while (searching) {\n    categories = compact_default(flatten_default(map_default(categories, (currTokType) => currTokType.CATEGORIES)));\n    const newCategories = difference_default(categories, result);\n    result = result.concat(newCategories);\n    if (isEmpty_default(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nfunction assignTokenDefaultProps(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    }\n    if (hasCategoriesProperty(currTokType) && !isArray_default(currTokType.CATEGORIES)) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nfunction assignCategoriesTokensProp(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    currTokType.categoryMatches = [];\n    forEach_default(currTokType.categoryMatchesMap, (val, key) => {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nfunction assignCategoriesMapProp(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  forEach_default(path, (pathNode) => {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach_default(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode);\n    if (!includes_default(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nfunction hasShortKeyProperty(tokType) {\n  return has_default(tokType, \"tokenTypeIdx\");\n}\nfunction hasCategoriesProperty(tokType) {\n  return has_default(tokType, \"CATEGORIES\");\n}\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return has_default(tokType, \"categoryMatches\");\n}\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return has_default(tokType, \"categoryMatchesMap\");\n}\nfunction isTokenType(tokType) {\n  return has_default(tokType, \"tokenTypeIdx\");\n}\n\n// lib/src/scan/lexer_errors_public.js\nvar defaultLexerErrorProvider = {\n  buildUnableToPopLexerModeMessage(token) {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n  },\n  buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n    return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;\n  }\n};\n\n// lib/src/scan/lexer_public.js\nvar LexerDefinitionErrorType;\n(function(LexerDefinitionErrorType2) {\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = class {\n  constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++;\n        const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          console.log(`${indent}--> <${phaseDesc}>`);\n        }\n        const { time, value } = timer(phaseImpl);\n        const traceMethod = time > 10 ? console.warn : console.log;\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n        }\n        this.traceInitIndent--;\n        return value;\n      } else {\n        return phaseImpl();\n      }\n    };\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n    }\n    this.config = assign_default({}, DEFAULT_LEXER_CONFIG, config);\n    const traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition;\n      let hasOnlySingleMode = true;\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\n        if (isArray_default(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone_default(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          };\n        } else {\n          hasOnlySingleMode = false;\n          actualDefinition = clone_default(lexerDefinition);\n        }\n      });\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n      }\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      forEach_default(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject_default(currModeValue, (currTokType) => isUndefined_default(currTokType));\n      });\n      const allModeNames = keys_default(actualDefinition.modes);\n      forEach_default(actualDefinition.modes, (currModDef, currModName) => {\n        this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n          this.modes.push(currModName);\n          if (this.config.skipValidations === false) {\n            this.TRACE_INIT(`validatePatterns`, () => {\n              this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          }\n          if (isEmpty_default(this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            let currAnalyzeResult;\n            this.TRACE_INIT(`analyzeTokenTypes`, () => {\n              currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: this.TRACE_INIT\n              });\n            });\n            this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n            this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n            this.emptyGroups = assign_default({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n            this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n            this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n          }\n        });\n      });\n      this.defaultMode = actualDefinition.defaultMode;\n      if (!isEmpty_default(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n        const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {\n          return error.message;\n        });\n        const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      forEach_default(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        if (SUPPORT_STICKY) {\n          this.chopInput = identity_default;\n          this.match = this.matchWithTest;\n        } else {\n          this.updateLastIndex = noop_default;\n          this.match = this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          this.handleModes = noop_default;\n        }\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity_default;\n        }\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop_default;\n        }\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken;\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken;\n        } else {\n          throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n        }\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush;\n          this.handlePayload = this.handlePayloadWithCustom;\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess;\n          this.handlePayload = this.handlePayloadNoCustom;\n        }\n      });\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce_default(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !isEmpty_default(unOptimizedModes)) {\n          throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\n\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`);\n        }\n      });\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache();\n      });\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this);\n      });\n    });\n  }\n  tokenize(text, initialMode = this.defaultMode) {\n    if (!isEmpty_default(this.lexerDefinitionErrors)) {\n      const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {\n        return error.message;\n      });\n      const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    return this.tokenizeInternal(text, initialMode);\n  }\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  tokenizeInternal(text, initialMode) {\n    let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    const orgText = text;\n    const orgLength = orgText.length;\n    let offset = 0;\n    let matchedTokensIndex = 0;\n    const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n    const matchedTokens = new Array(guessedNumberOfTokens);\n    const errors = [];\n    let line = this.trackStartLines ? 1 : void 0;\n    let column = this.trackStartLines ? 1 : void 0;\n    const groups = cloneEmptyGroups(this.emptyGroups);\n    const trackLines = this.trackStartLines;\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    let currModePatternsLength = 0;\n    let patternIdxToConfig = [];\n    let currCharCodeToPatternIdxToConfig = [];\n    const modeStack = [];\n    const emptyArray = [];\n    Object.freeze(emptyArray);\n    let getPossiblePatterns;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === void 0) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    const pop_mode = (popToken) => {\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === void 0) {\n        const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg2\n        });\n      } else {\n        modeStack.pop();\n        const newMode = last_default(modeStack);\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    push_mode.call(this, initialMode);\n    let currConfig;\n    const recoveryEnabled = this.config.recoveryEnabled;\n    while (offset < orgLength) {\n      matchedImage = null;\n      const nextCharCode = orgText.charCodeAt(offset);\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        const currPattern = currConfig.pattern;\n        payload = null;\n        const singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== void 0) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== void 0) {\n            const longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              const longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n              if (longerAltConfig.isCustom === true) {\n                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (match.payload !== void 0) {\n                    altPayload = match.payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern, offset);\n                matchAltImage = this.match(longerAltPattern, text, offset);\n              }\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== void 0) {\n          tokType = currConfig.tokenTypeIdx;\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0;\n          let foundTerminator;\n          let lastLTEndOffset;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        const errorStartOffset = offset;\n        const errorLine = line;\n        const errorColumn = column;\n        let foundResyncPoint = recoveryEnabled === false;\n        while (foundResyncPoint === false && offset < orgLength) {\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig2 = patternIdxToConfig[j];\n            const currPattern = currConfig2.pattern;\n            const singleCharCode = currConfig2.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                foundResyncPoint = true;\n              }\n            } else if (currConfig2.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        column = this.computeNewColumn(column, errLength);\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n    if (!this.hasCustom) {\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups,\n      errors\n    };\n  }\n  handleModes(config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      const pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== void 0) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== void 0) {\n      push_mode.call(this, config.push);\n    }\n  }\n  chopInput(text, length) {\n    return text.substring(length);\n  }\n  updateLastIndex(regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    let lastCharIsLT, fixForEndingInLT;\n    if (group !== void 0) {\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        newToken.endLine = line + fixForEndingInLT;\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n    }\n  }\n  computeNewColumn(oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  }\n  createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  addTokenUsingPush(tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  }\n  addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }\n  handlePayloadNoCustom(token, payload) {\n  }\n  handlePayloadWithCustom(token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  }\n  matchWithTest(pattern, text, offset) {\n    const found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  }\n  matchWithExec(pattern, text) {\n    const regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  }\n};\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\n\n// lib/src/scan/tokens_public.js\nfunction tokenLabel2(tokType) {\n  if (hasTokenLabel2(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\nfunction tokenName(tokType) {\n  return tokType.name;\n}\nfunction hasTokenLabel2(obj) {\n  return isString_default(obj.LABEL) && obj.LABEL !== \"\";\n}\nvar PARENT = \"parent\";\nvar CATEGORIES = \"categories\";\nvar LABEL = \"label\";\nvar GROUP = \"group\";\nvar PUSH_MODE = \"push_mode\";\nvar POP_MODE = \"pop_mode\";\nvar LONGER_ALT = \"longer_alt\";\nvar LINE_BREAKS = \"line_breaks\";\nvar START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n  return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n  const pattern = config.pattern;\n  const tokenType = {};\n  tokenType.name = config.name;\n  if (!isUndefined_default(pattern)) {\n    tokenType.PATTERN = pattern;\n  }\n  if (has_default(config, PARENT)) {\n    throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n  }\n  if (has_default(config, CATEGORIES)) {\n    tokenType.CATEGORIES = config[CATEGORIES];\n  }\n  augmentTokenTypes([tokenType]);\n  if (has_default(config, LABEL)) {\n    tokenType.LABEL = config[LABEL];\n  }\n  if (has_default(config, GROUP)) {\n    tokenType.GROUP = config[GROUP];\n  }\n  if (has_default(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE];\n  }\n  if (has_default(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE];\n  }\n  if (has_default(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT];\n  }\n  if (has_default(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\n  }\n  if (has_default(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n  }\n  return tokenType;\n}\nvar EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: tokType.tokenTypeIdx,\n    tokenType: tokType\n  };\n}\nfunction tokenMatcher(token, tokType) {\n  return tokenStructuredMatcher(token, tokType);\n}\n\n// lib/src/parse/errors_public.js\nvar defaultParserErrorProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n    const hasLabel = hasTokenLabel2(expected);\n    const expectedMsg = hasLabel ? `--> ${tokenLabel2(expected)} <--` : `token of type --> ${expected.name} <--`;\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n    return msg;\n  },\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head_default(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce_default(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n      const nextValidTokenSequences = map_default(allLookAheadPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(\", \")}]`);\n      const nextValidSequenceItems = map_default(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n      const calculatedDescription = `one of these possible Token sequences:\n${nextValidSequenceItems.join(\"\\n\")}`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head_default(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map_default(expectedIterationPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(\",\")}]`);\n      const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\n  <${nextValidTokenSequences.join(\" ,\")}>`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nvar defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nvar defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument2(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    const topLevelName = topLevelRule.name;\n    const duplicateProd = head_default(duplicateProds);\n    const index = duplicateProd.idx;\n    const dslName = getProductionDslName(duplicateProd);\n    const extraArgument = getExtraProductionArgument2(duplicateProd);\n    const hasExplicitIndex = index > 0;\n    let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError(rule) {\n    const errMsg = `Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.`;\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError(options) {\n    const pathMsg = map_default(options.prefixPath, (currTok) => tokenLabel2(currTok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\nin <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.`;\n    return errMsg;\n  },\n  buildAlternationAmbiguityError(options) {\n    const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n    return currMessage;\n  },\n  buildEmptyRepetitionError(options) {\n    let dslName = getProductionDslName(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\nThis could lead to an infinite loop.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options) {\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError(options) {\n    const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\nOnly the last alternative may be an empty alternative.`;\n    return errMsg;\n  },\n  buildTooManyAlternativesError(options) {\n    const errMsg = `An Alternation cannot have more than 256 alternatives:\n<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n has ${options.alternation.definition.length + 1} alternatives.`;\n    return errMsg;\n  },\n  buildLeftRecursionError(options) {\n    const ruleName = options.topLevelRule.name;\n    const pathNames = map_default(options.leftRecursionPath, (currRule) => currRule.name);\n    const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(\" --> \")}`;\n    const errMsg = `Left Recursion found in grammar.\nrule: <${ruleName}> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n ${leftRecursivePath}\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options) {\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError(options) {\n    let ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n    return errMsg;\n  }\n};\n\n// lib/src/parse/grammar/resolver.js\nfunction resolveGrammar(topLevels, errMsgProvider) {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n  refResolver.resolveRefs();\n  return refResolver.errors;\n}\nvar GastRefResolverVisitor = class extends GAstVisitor {\n  constructor(nameToTopRule, errMsgProvider) {\n    super();\n    this.nameToTopRule = nameToTopRule;\n    this.errMsgProvider = errMsgProvider;\n    this.errors = [];\n  }\n  resolveRefs() {\n    forEach_default(values_default(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod;\n      prod.accept(this);\n    });\n  }\n  visitNonTerminal(node) {\n    const ref = this.nameToTopRule[node.nonTerminalName];\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      });\n    } else {\n      node.referencedRule = ref;\n    }\n  }\n};\n\n// lib/src/parse/grammar/interpreter.js\nvar AbstractNextPossibleTokensWalker = class extends RestWalker {\n  constructor(topProd, path) {\n    super();\n    this.topProd = topProd;\n    this.path = path;\n    this.possibleTokTypes = [];\n    this.nextProductionName = \"\";\n    this.nextProductionOccurrence = 0;\n    this.found = false;\n    this.isAtEndOfPath = false;\n  }\n  startWalking() {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    this.ruleStack = clone_default(this.path.ruleStack).reverse();\n    this.occurrenceStack = clone_default(this.path.occurrenceStack).reverse();\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  }\n  walk(prod, prevRest = []) {\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  }\n  updateExpectedNext() {\n    if (isEmpty_default(this.ruleStack)) {\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  }\n};\nvar NextAfterTokenWalker = class extends AbstractNextPossibleTokensWalker {\n  constructor(topProd, path) {\n    super(topProd, path);\n    this.path = path;\n    this.nextTerminalName = \"\";\n    this.nextTerminalOccurrence = 0;\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n};\nvar AbstractNextTerminalAfterProductionWalker = class extends RestWalker {\n  constructor(topRule, occurrence) {\n    super();\n    this.topRule = topRule;\n    this.occurrence = occurrence;\n    this.result = {\n      token: void 0,\n      occurrence: void 0,\n      isEndOfRule: void 0\n    };\n  }\n  startWalking() {\n    this.walk(this.topRule);\n    return this.result;\n  }\n};\nvar NextTerminalAfterManyWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === void 0;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterManySepWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === void 0;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterAtLeastOneWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterAtLeastOneSepWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n};\nfunction possiblePathsFrom(targetDef, maxLength, currPath = []) {\n  currPath = clone_default(currPath);\n  let result = [];\n  let i = 0;\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop_default(targetDef, i + 1));\n  }\n  function getAlternativesForProd(definition) {\n    const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach_default(prod.definition, (currAlt) => {\n        if (isEmpty_default(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop_default(targetDef, i)\n  });\n  return result;\n}\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  const result = [];\n  const possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty_default(possiblePaths)) {\n    const currPath = possiblePaths.pop();\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last_default(possiblePaths).idx <= minimalAlternativesIndex) {\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n    if (isEmpty_default(currDef)) {\n      continue;\n    }\n    const prod = currDef[0];\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: dropRight_default(currRuleStack),\n        occurrenceStack: dropRight_default(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop_default(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n      } else if (currIdx === tokenVectorLength - 1) {\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone_default(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      const newOccurrenceStack = clone_default(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop_default(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop_default(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop_default(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop_default(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  const newRuleStack = clone_default(currRuleStack);\n  newRuleStack.push(topRule.name);\n  const newCurrOccurrenceStack = clone_default(currOccurrenceStack);\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}\n\n// lib/src/parse/grammar/lookahead.js\nvar PROD_TYPE;\n(function(PROD_TYPE2) {\n  PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType(prod) {\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory || prod === \"RepetitionMandatory\") {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getLookaheadPaths(options) {\n  const { occurrence, rule, prodType, maxLookahead } = options;\n  const type = getProdType(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n  }\n}\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n}\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n}\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n  const numOfAlts = alts.length;\n  const areAllOneTokenLookahead = every_default(alts, (currAlt) => {\n    return every_default(currAlt, (currPath) => {\n      return currPath.length === 1;\n    });\n  });\n  if (hasPredicates) {\n    return function(orAlts) {\n      const predicates = map_default(orAlts, (currAlt) => currAlt.GATE);\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        const currPredicate = predicates[t];\n        if (currPredicate !== void 0 && currPredicate.call(this) === false) {\n          continue;\n        }\n        nextPath:\n          for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j];\n            const currPathLength = currPath.length;\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1);\n              if (tokenMatcher2(nextToken, currPath[i]) === false) {\n                continue nextPath;\n              }\n            }\n            return t;\n          }\n      }\n      return void 0;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokenAlts = map_default(alts, (currAlt) => {\n      return flatten_default(currAlt);\n    });\n    const choiceToAlt = reduce_default(singleTokenAlts, (result, currAlt, idx) => {\n      forEach_default(currAlt, (currTokType) => {\n        if (!has_default(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n          if (!has_default(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, {});\n    return function() {\n      const nextToken = this.LA(1);\n      return choiceToAlt[nextToken.tokenTypeIdx];\n    };\n  } else {\n    return function() {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        nextPath:\n          for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j];\n            const currPathLength = currPath.length;\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1);\n              if (tokenMatcher2(nextToken, currPath[i]) === false) {\n                continue nextPath;\n              }\n            }\n            return t;\n          }\n      }\n      return void 0;\n    };\n  }\n}\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n  const areAllOneTokenLookahead = every_default(alt, (currPath) => {\n    return currPath.length === 1;\n  });\n  const numOfPaths = alt.length;\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten_default(alt);\n    if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {\n      const expectedTokenType = singleTokensTypes[0];\n      const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n      return function() {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n      };\n    } else {\n      const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType, idx) => {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function() {\n        const nextToken = this.LA(1);\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function() {\n      nextPath:\n        for (let j = 0; j < numOfPaths; j++) {\n          const currPath = alt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher2(nextToken, currPath[i]) === false) {\n              continue nextPath;\n            }\n          }\n          return true;\n        }\n      return false;\n    };\n  }\n}\nvar RestDefinitionFinderWalker = class extends RestWalker {\n  constructor(topProd, targetOccurrence, targetProdType) {\n    super();\n    this.topProd = topProd;\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.restDef;\n  }\n  checkIsTarget(node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    return false;\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      super.walkOption(manyProd, currRest, prevRest);\n    }\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(manySepProd, currRest, prevRest);\n    }\n  }\n};\nvar InsideDefinitionFinderVisitor = class extends GAstVisitor {\n  constructor(targetOccurrence, targetProdType, targetRef) {\n    super();\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n    this.targetRef = targetRef;\n    this.result = [];\n  }\n  checkIsTarget(node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  }\n  visitOption(node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  }\n  visitRepetition(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  }\n  visitRepetitionMandatory(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  }\n  visitRepetitionMandatoryWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  }\n  visitRepetitionWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  }\n  visitAlternation(node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  }\n};\nfunction initializeArrayOfArrays(size) {\n  const result = new Array(size);\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\nfunction pathToHashKeys(path) {\n  let keys2 = [\"\"];\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i];\n    const longerKeys = [];\n    for (let j = 0; j < keys2.length; j++) {\n      const currShorterKey = keys2[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (let t = 0; t < tokType.categoryMatches.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys2 = longerKeys;\n  }\n  return keys2;\n}\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    if (currAltIdx === idx) {\n      continue;\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  const partialAlts = map_default(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\n  const altsHashes = map_default(partialAlts, (currAltPaths) => {\n    const dict = {};\n    forEach_default(currAltPaths, (item) => {\n      const keys2 = pathToHashKeys(item.partialPath);\n      forEach_default(keys2, (currKey) => {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  let newData = partialAlts;\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx];\n      for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        const prefixKeys = pathToHashKeys(currPathPrefix);\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        if (isUnique || isEmpty_default(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx];\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          forEach_default(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys2 = pathToHashKeys(item.partialPath);\n            forEach_default(prefixKeys2, (key) => {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }\n  }\n  return finalResult;\n}\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  const insideDef = insideDefVisitor.result;\n  const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  const afterDef = afterDefWalker.startWalking();\n  const insideFlat = new Alternative({ definition: insideDef });\n  const afterFlat = new Alternative({ definition: afterDef });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath:\n    for (let i = 0; i < alternative.length; i++) {\n      const otherPath = alternative[i];\n      if (otherPath.length !== searchPath.length) {\n        continue;\n      }\n      for (let j = 0; j < otherPath.length; j++) {\n        const searchTok = searchPath[j];\n        const otherTok = otherPath[j];\n        const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n        if (matchingTokens === false) {\n          continue compareOtherPath;\n        }\n      }\n      return true;\n    }\n  return false;\n}\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every_default(prefix, (tokType, idx) => {\n    const otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every_default(lookAheadPaths, (singleAltPaths) => every_default(singleAltPaths, (singlePath) => every_default(singlePath, (token) => isEmpty_default(token.categoryMatches))));\n}\n\n// lib/src/parse/grammar/checks.js\nfunction validateLookahead(options) {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return map_default(lookaheadValidationErrorMessages, (errorMessage) => Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage));\n}\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  const duplicateErrors = flatMap_default(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  const tooManyAltsErrors = flatMap_default(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n  const duplicateRulesError = flatMap_default(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  const collectorVisitor2 = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor2);\n  const allRuleProductions = collectorVisitor2.allProductions;\n  const productionGroups = groupBy_default(allRuleProductions, identifyProductionForDuplicates);\n  const duplicates = pickBy_default(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n  const errors = map_default(values_default(duplicates), (currDuplicates) => {\n    const firstProd = head_default(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    const dslName = getProductionDslName(firstProd);\n    const defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName,\n      occurrence: firstProd.idx\n    };\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = class extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitNonTerminal(subrule) {\n    this.allProductions.push(subrule);\n  }\n  visitOption(option) {\n    this.allProductions.push(option);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n  visitAlternation(or) {\n    this.allProductions.push(or);\n  }\n  visitTerminal(terminal) {\n    this.allProductions.push(terminal);\n  }\n};\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  const errors = [];\n  const occurrences = reduce_default(allRules, (result, curRule) => {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  const errors = [];\n  let errMsg;\n  if (!includes_default(definedRulesNames, ruleName)) {\n    errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName\n    });\n  }\n  return errors;\n}\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n  const errors = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty_default(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes_default(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName\n      });\n    }\n    const validNextSteps = difference_default(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap_default(validNextSteps, (currRefRule) => {\n      const newPath = clone_default(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nfunction getFirstNoneTerminal(definition) {\n  let result = [];\n  if (isEmpty_default(definition)) {\n    return result;\n  }\n  const firstProd = head_default(definition);\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    result = flatten_default(map_default(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n  } else if (firstProd instanceof Terminal) {\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop_default(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nvar OrCollector = class extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.alternations = [];\n  }\n  visitAlternation(node) {\n    this.alternations.push(node);\n  }\n};\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap_default(ors, (currOr) => {\n    const exceptLast = dropRight_default(currOr.definition);\n    return flatMap_default(exceptLast, (currAlternative, currAltIdx) => {\n      const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n      if (isEmpty_default(possibleFirstInAlt)) {\n        return [\n          {\n            message: errMsgProvider.buildEmptyAlternationError({\n              topLevelRule,\n              alternation: currOr,\n              emptyChoiceIdx: currAltIdx\n            }),\n            type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n            alternative: currAltIdx + 1\n          }\n        ];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n  ors = reject_default(ors, (currOr) => currOr.ignoreAmbiguities === true);\n  const errors = flatMap_default(ors, (currOr) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nvar RepetitionCollector = class extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n};\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap_default(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  const errors = [];\n  forEach_default(topLevelRules, (currTopRule) => {\n    const collectorVisitor2 = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor2);\n    const allRuleProductions = collectorVisitor2.allProductions;\n    forEach_default(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      const pathsInsideProduction = paths[0];\n      if (isEmpty_default(flatten_default(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  const foundAmbiguousPaths = [];\n  const identicalAmbiguities = reduce_default(alternatives, (result, currAlt, currAltIdx) => {\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach_default(currAlt, (currPath) => {\n      const altsCurrPathAppearsIn = [currAltIdx];\n      forEach_default(alternatives, (currOtherAlt, currOtherAltIdx) => {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  const currErrors = map_default(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map_default(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  const pathsAndIndices = reduce_default(alternatives, (result, currAlt, idx) => {\n    const currPathsAndIdx = map_default(currAlt, (currPath) => {\n      return { idx, path: currPath };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  const errors = compact_default(flatMap_default(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx];\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    const targetIdx = currPathAndIdx.idx;\n    const targetPath = currPathAndIdx.path;\n    const prefixAmbiguitiesPathsAndIndices = filter_default(pathsAndIndices, (searchPathAndIdx) => {\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    const currPathPrefixErrors = map_default(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  const errors = [];\n  const tokenNames = map_default(tokenTypes, (currToken) => currToken.name);\n  forEach_default(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes_default(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}\n\n// lib/src/parse/grammar/gast/gast_resolver_public.js\nfunction resolveGrammar2(options) {\n  const actualOptions = defaults_default(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  });\n  const topRulesTable = {};\n  forEach_default(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule;\n  });\n  return resolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nfunction validateGrammar2(options) {\n  options = defaults_default(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  });\n  return validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n\n// lib/src/parse/exceptions_public.js\nvar MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\nfunction isRecognitionException(error) {\n  return includes_default(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nvar RecognitionException = class extends Error {\n  constructor(message, token) {\n    super(message);\n    this.token = token;\n    this.resyncedTokens = [];\n    Object.setPrototypeOf(this, new.target.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n};\nvar MismatchedTokenException = class extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n  }\n};\nvar NoViableAltException = class extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n  }\n};\nvar NotAllInputParsedException = class extends RecognitionException {\n  constructor(message, token) {\n    super(message, token);\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n  }\n};\nvar EarlyExitException = class extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = EARLY_EXIT_EXCEPTION;\n  }\n};\n\n// lib/src/parse/parser/traits/recoverable.js\nvar EOF_FOLLOW_KEY = {};\nvar IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar InRuleRecoveryException = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n  }\n};\nvar Recoverable = class {\n  initRecoverable(config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has_default(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n  getTokenToInsert(tokType) {\n    const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n  canTokenTypeBeInsertedInRecovery(tokType) {\n    return true;\n  }\n  canTokenTypeBeDeletedInRecovery(tokType) {\n    return true;\n  }\n  tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens = [];\n    let passedResyncPoint = false;\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0);\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n      const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n      error.resyncedTokens = dropRight_default(resyncedTokens);\n      this.SAVE_ERROR(error);\n    };\n    while (!passedResyncPoint) {\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return;\n      } else if (lookAheadFunc.call(this)) {\n        generateErrorMessage();\n        grammarRule.apply(this, grammarRuleArgs);\n        return;\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n    this.importLexerState(savedLexerState);\n  }\n  shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    if (notStuck === false) {\n      return false;\n    }\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n    if (this.isBackTracking()) {\n      return false;\n    }\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n    return true;\n  }\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n  tryInRuleRecovery(expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n  canPerformInRuleRecovery(expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  }\n  canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n    if (isEmpty_default(follows)) {\n      return false;\n    }\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows = find_default(follows, (possibleFollowsTokType) => {\n      return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== void 0;\n    return isMisMatchedTokInFollows;\n  }\n  canRecoverWithSingleTokenDeletion(expectedTokType) {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n    const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  }\n  isInCurrentRuleReSyncSet(tokenTypeIdx) {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return includes_default(currentRuleReSyncSet, tokenTypeIdx);\n  }\n  findReSyncTokenType() {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    let nextToken = this.LA(1);\n    let k = 2;\n    while (true) {\n      const foundMatch = find_default(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== void 0) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n  getCurrFollowKey() {\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  }\n  buildFullFollowKeyStack() {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return map_default(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  }\n  flattenFollowSet() {\n    const followStack = map_default(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten_default(followStack);\n  }\n  getFollowSetFromFollowKey(followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n    const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  }\n  reSyncTo(tokType) {\n    const resyncedTokens = [];\n    let nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    return dropRight_default(resyncedTokens);\n  }\n  attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  }\n  getCurrentGrammarPath(tokType, tokIdxInRule) {\n    const pathRuleStack = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack = clone_default(this.RULE_OCCURRENCE_STACK);\n    const grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  }\n  getHumanReadableRuleStack() {\n    return map_default(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n  }\n};\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === void 0) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n  if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {\n    return;\n  }\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}\n\n// lib/src/parse/grammar/keys.js\nvar BITS_FOR_METHOD_TYPE = 4;\nvar BITS_FOR_OCCURRENCE_IDX = 8;\nvar BITS_FOR_ALT_IDX = 8;\nvar OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nvar OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n\n// lib/src/parse/grammar/llk_lookahead.js\nvar LLkLookaheadStrategy = class {\n  constructor(options) {\n    var _a;\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  validate(options) {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if (isEmpty_default(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ];\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  }\n  validateNoLeftRecursion(rules) {\n    return flatMap_default(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateEmptyOrAlternatives(rules) {\n    return flatMap_default(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n    return flatMap_default(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n  }\n  validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n    return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n  }\n  buildLookaheadForAlternation(options) {\n    return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n  }\n  buildLookaheadForOptional(options) {\n    return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n  }\n};\n\n// lib/src/parse/parser/traits/looksahead.js\nvar LooksAhead = class {\n  initLooksAhead(config) {\n    this.dynamicTokensEnabled = has_default(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = has_default(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookaheadStrategy = has_default(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n    this.lookAheadFuncsCache = /* @__PURE__ */ new Map();\n  }\n  preComputeLookaheadFunctions(rules) {\n    forEach_default(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);\n        forEach_default(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n        forEach_default(repetition, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(option, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n      });\n    });\n  }\n  computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n      const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n        prodOccurrence,\n        rule,\n        maxLookahead: prodMaxLookahead || this.maxLookahead,\n        dynamicTokensEnabled: this.dynamicTokensEnabled,\n        prodType\n      });\n      const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      this.setLaFuncCache(key, laFunc);\n    });\n  }\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n  }\n  getLaFuncFromCache(key) {\n    return this.lookAheadFuncsCache.get(key);\n  }\n  /* istanbul ignore next */\n  setLaFuncCache(key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n};\nvar DslMethodsCollectorVisitor = class extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  visitOption(option) {\n    this.dslMethods.option.push(option);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.dslMethods.repetition.push(many);\n  }\n  visitAlternation(or) {\n    this.dslMethods.alternation.push(or);\n  }\n};\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods;\n  collectorVisitor.reset();\n  return dslMethods;\n}\n\n// lib/src/parse/cst/cst.js\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nfunction addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === void 0) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === void 0) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n\n// lib/src/lang/lang_extensions.js\nvar NAME = \"name\";\nfunction defineNameProp(obj, nameValue) {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue\n  });\n}\n\n// lib/src/parse/cst/cst_visitor.js\nfunction defaultVisit(ctx, param) {\n  const childrenNames = keys_default(ctx);\n  const childrenNamesLength = childrenNames.length;\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild = currChildArray[j];\n      if (currChild.tokenTypeIdx === void 0) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n}\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  const derivedConstructor = function() {\n  };\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  const semanticProto = {\n    visit: function(cstNode, param) {\n      if (isArray_default(cstNode)) {\n        cstNode = cstNode[0];\n      }\n      if (isUndefined_default(cstNode)) {\n        return void 0;\n      }\n      return this[cstNode.name](cstNode.children, param);\n    },\n    validateVisitor: function() {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty_default(semanticDefinitionErrors)) {\n        const errorMessages = map_default(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\n\t${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")}`);\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  const derivedConstructor = function() {\n  };\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach_default(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\nvar CstVisitorDefinitionError;\n(function(CstVisitorDefinitionError2) {\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  return missingErrors;\n}\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n  const missingRuleNames = filter_default(ruleNames, (currRuleName) => {\n    return isFunction_default(visitorInstance[currRuleName]) === false;\n  });\n  const errors = map_default(missingRuleNames, (currRuleName) => {\n    return {\n      msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n      type: CstVisitorDefinitionError.MISSING_METHOD,\n      methodName: currRuleName\n    };\n  });\n  return compact_default(errors);\n}\n\n// lib/src/parse/parser/traits/tree_builder.js\nvar TreeBuilder = class {\n  initTreeBuilder(config) {\n    this.CST_STACK = [];\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = has_default(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop_default;\n      this.cstFinallyStateUpdate = noop_default;\n      this.cstPostTerminal = noop_default;\n      this.cstPostNonTerminal = noop_default;\n      this.cstPostRule = noop_default;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = noop_default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_default;\n          this.setNodeLocationFromNode = noop_default;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = noop_default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_default;\n          this.setNodeLocationFromNode = noop_default;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop_default;\n        this.setNodeLocationFromNode = noop_default;\n        this.cstPostRule = noop_default;\n        this.setInitialNodeLocation = noop_default;\n      } else {\n        throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n      }\n    }\n  }\n  setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationFullRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n  setInitialNodeLocationFullRegular(cstNode) {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  cstInvocationStateUpdate(fullRuleName) {\n    const cstNode = {\n      name: fullRuleName,\n      children: /* @__PURE__ */ Object.create(null)\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n  cstFinallyStateUpdate() {\n    this.CST_STACK.pop();\n  }\n  cstPostRuleFull(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  }\n  cstPostRuleOnlyOffset(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } else {\n      loc.startOffset = NaN;\n    }\n  }\n  cstPostTerminal(key, consumedToken) {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  }\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  }\n  getBaseCstVisitorConstructor() {\n    if (isUndefined_default(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys_default(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  }\n  getBaseCstVisitorConstructorWithDefaults() {\n    if (isUndefined_default(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys_default(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  }\n  getLastExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n  getPreviousExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n  getLastExplicitRuleOccurrenceIndex() {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n};\n\n// lib/src/parse/parser/traits/lexer_adapter.js\nvar LexerAdapter = class {\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n  set input(newInput) {\n    if (this.selfAnalysisDone !== true) {\n      throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n    }\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n  get input() {\n    return this.tokVector;\n  }\n  // skips a token and returns the next token\n  SKIP_TOKEN() {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  }\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(howMuch) {\n    const soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n  consumeToken() {\n    this.currIdx++;\n  }\n  exportLexerState() {\n    return this.currIdx;\n  }\n  importLexerState(newState) {\n    this.currIdx = newState;\n  }\n  resetLexerState() {\n    this.currIdx = -1;\n  }\n  moveToTerminatedState() {\n    this.currIdx = this.tokVector.length - 1;\n  }\n  getLexerPosition() {\n    return this.exportLexerState();\n  }\n};\n\n// lib/src/parse/parser/traits/recognizer_api.js\nvar RecognizerApi = class {\n  ACTION(impl) {\n    return impl.call(this);\n  }\n  consume(idx, tokType, options) {\n    return this.consumeInternal(tokType, idx, options);\n  }\n  subrule(idx, ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, idx, options);\n  }\n  option(idx, actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, idx);\n  }\n  or(idx, altsOrOpts) {\n    return this.orInternal(altsOrOpts, idx);\n  }\n  many(idx, actionORMethodDef) {\n    return this.manyInternal(idx, actionORMethodDef);\n  }\n  atLeastOne(idx, actionORMethodDef) {\n    return this.atLeastOneInternal(idx, actionORMethodDef);\n  }\n  CONSUME(tokType, options) {\n    return this.consumeInternal(tokType, 0, options);\n  }\n  CONSUME1(tokType, options) {\n    return this.consumeInternal(tokType, 1, options);\n  }\n  CONSUME2(tokType, options) {\n    return this.consumeInternal(tokType, 2, options);\n  }\n  CONSUME3(tokType, options) {\n    return this.consumeInternal(tokType, 3, options);\n  }\n  CONSUME4(tokType, options) {\n    return this.consumeInternal(tokType, 4, options);\n  }\n  CONSUME5(tokType, options) {\n    return this.consumeInternal(tokType, 5, options);\n  }\n  CONSUME6(tokType, options) {\n    return this.consumeInternal(tokType, 6, options);\n  }\n  CONSUME7(tokType, options) {\n    return this.consumeInternal(tokType, 7, options);\n  }\n  CONSUME8(tokType, options) {\n    return this.consumeInternal(tokType, 8, options);\n  }\n  CONSUME9(tokType, options) {\n    return this.consumeInternal(tokType, 9, options);\n  }\n  SUBRULE(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 0, options);\n  }\n  SUBRULE1(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 1, options);\n  }\n  SUBRULE2(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 2, options);\n  }\n  SUBRULE3(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 3, options);\n  }\n  SUBRULE4(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 4, options);\n  }\n  SUBRULE5(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 5, options);\n  }\n  SUBRULE6(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 6, options);\n  }\n  SUBRULE7(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 7, options);\n  }\n  SUBRULE8(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 8, options);\n  }\n  SUBRULE9(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 9, options);\n  }\n  OPTION(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 0);\n  }\n  OPTION1(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 1);\n  }\n  OPTION2(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 2);\n  }\n  OPTION3(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 3);\n  }\n  OPTION4(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 4);\n  }\n  OPTION5(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 5);\n  }\n  OPTION6(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 6);\n  }\n  OPTION7(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 7);\n  }\n  OPTION8(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 8);\n  }\n  OPTION9(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 9);\n  }\n  OR(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 0);\n  }\n  OR1(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 1);\n  }\n  OR2(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 2);\n  }\n  OR3(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 3);\n  }\n  OR4(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 4);\n  }\n  OR5(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 5);\n  }\n  OR6(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 6);\n  }\n  OR7(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 7);\n  }\n  OR8(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 8);\n  }\n  OR9(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 9);\n  }\n  MANY(actionORMethodDef) {\n    this.manyInternal(0, actionORMethodDef);\n  }\n  MANY1(actionORMethodDef) {\n    this.manyInternal(1, actionORMethodDef);\n  }\n  MANY2(actionORMethodDef) {\n    this.manyInternal(2, actionORMethodDef);\n  }\n  MANY3(actionORMethodDef) {\n    this.manyInternal(3, actionORMethodDef);\n  }\n  MANY4(actionORMethodDef) {\n    this.manyInternal(4, actionORMethodDef);\n  }\n  MANY5(actionORMethodDef) {\n    this.manyInternal(5, actionORMethodDef);\n  }\n  MANY6(actionORMethodDef) {\n    this.manyInternal(6, actionORMethodDef);\n  }\n  MANY7(actionORMethodDef) {\n    this.manyInternal(7, actionORMethodDef);\n  }\n  MANY8(actionORMethodDef) {\n    this.manyInternal(8, actionORMethodDef);\n  }\n  MANY9(actionORMethodDef) {\n    this.manyInternal(9, actionORMethodDef);\n  }\n  MANY_SEP(options) {\n    this.manySepFirstInternal(0, options);\n  }\n  MANY_SEP1(options) {\n    this.manySepFirstInternal(1, options);\n  }\n  MANY_SEP2(options) {\n    this.manySepFirstInternal(2, options);\n  }\n  MANY_SEP3(options) {\n    this.manySepFirstInternal(3, options);\n  }\n  MANY_SEP4(options) {\n    this.manySepFirstInternal(4, options);\n  }\n  MANY_SEP5(options) {\n    this.manySepFirstInternal(5, options);\n  }\n  MANY_SEP6(options) {\n    this.manySepFirstInternal(6, options);\n  }\n  MANY_SEP7(options) {\n    this.manySepFirstInternal(7, options);\n  }\n  MANY_SEP8(options) {\n    this.manySepFirstInternal(8, options);\n  }\n  MANY_SEP9(options) {\n    this.manySepFirstInternal(9, options);\n  }\n  AT_LEAST_ONE(actionORMethodDef) {\n    this.atLeastOneInternal(0, actionORMethodDef);\n  }\n  AT_LEAST_ONE1(actionORMethodDef) {\n    return this.atLeastOneInternal(1, actionORMethodDef);\n  }\n  AT_LEAST_ONE2(actionORMethodDef) {\n    this.atLeastOneInternal(2, actionORMethodDef);\n  }\n  AT_LEAST_ONE3(actionORMethodDef) {\n    this.atLeastOneInternal(3, actionORMethodDef);\n  }\n  AT_LEAST_ONE4(actionORMethodDef) {\n    this.atLeastOneInternal(4, actionORMethodDef);\n  }\n  AT_LEAST_ONE5(actionORMethodDef) {\n    this.atLeastOneInternal(5, actionORMethodDef);\n  }\n  AT_LEAST_ONE6(actionORMethodDef) {\n    this.atLeastOneInternal(6, actionORMethodDef);\n  }\n  AT_LEAST_ONE7(actionORMethodDef) {\n    this.atLeastOneInternal(7, actionORMethodDef);\n  }\n  AT_LEAST_ONE8(actionORMethodDef) {\n    this.atLeastOneInternal(8, actionORMethodDef);\n  }\n  AT_LEAST_ONE9(actionORMethodDef) {\n    this.atLeastOneInternal(9, actionORMethodDef);\n  }\n  AT_LEAST_ONE_SEP(options) {\n    this.atLeastOneSepFirstInternal(0, options);\n  }\n  AT_LEAST_ONE_SEP1(options) {\n    this.atLeastOneSepFirstInternal(1, options);\n  }\n  AT_LEAST_ONE_SEP2(options) {\n    this.atLeastOneSepFirstInternal(2, options);\n  }\n  AT_LEAST_ONE_SEP3(options) {\n    this.atLeastOneSepFirstInternal(3, options);\n  }\n  AT_LEAST_ONE_SEP4(options) {\n    this.atLeastOneSepFirstInternal(4, options);\n  }\n  AT_LEAST_ONE_SEP5(options) {\n    this.atLeastOneSepFirstInternal(5, options);\n  }\n  AT_LEAST_ONE_SEP6(options) {\n    this.atLeastOneSepFirstInternal(6, options);\n  }\n  AT_LEAST_ONE_SEP7(options) {\n    this.atLeastOneSepFirstInternal(7, options);\n  }\n  AT_LEAST_ONE_SEP8(options) {\n    this.atLeastOneSepFirstInternal(8, options);\n  }\n  AT_LEAST_ONE_SEP9(options) {\n    this.atLeastOneSepFirstInternal(9, options);\n  }\n  RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n    if (includes_default(this.definedRulesNames, name)) {\n      const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n        topLevelRule: name,\n        grammarName: this.className\n      });\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      };\n      this.definitionErrors.push(error);\n    }\n    this.definedRulesNames.push(name);\n    const ruleImplementation = this.defineRule(name, implementation, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n    const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n    const ruleImplementation = this.defineRule(name, impl, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  BACKTRACK(grammarRule, args) {\n    return function() {\n      this.isBackTrackingStack.push(1);\n      const orgState = this.saveRecogState();\n      try {\n        grammarRule.apply(this, args);\n        return true;\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false;\n        } else {\n          throw e;\n        }\n      } finally {\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    };\n  }\n  // GAST export APIs\n  getGAstProductions() {\n    return this.gastProductionsCache;\n  }\n  getSerializedGastProductions() {\n    return serializeGrammar(values_default(this.gastProductionsCache));\n  }\n};\n\n// lib/src/parse/parser/traits/recognizer_engine.js\nvar RecognizerEngine = class {\n  initRecognizerEngine(tokenVocabulary, config) {\n    this.className = this.constructor.name;\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if (has_default(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n    }\n    if (isArray_default(tokenVocabulary)) {\n      if (isEmpty_default(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n      }\n    }\n    if (isArray_default(tokenVocabulary)) {\n      this.tokensMap = reduce_default(tokenVocabulary, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has_default(tokenVocabulary, \"modes\") && every_default(flatten_default(values_default(tokenVocabulary.modes)), isTokenType)) {\n      const allTokenTypes2 = flatten_default(values_default(tokenVocabulary.modes));\n      const uniqueTokens = uniq_default(allTokenTypes2);\n      this.tokensMap = reduce_default(uniqueTokens, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject_default(tokenVocabulary)) {\n      this.tokensMap = clone_default(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    this.tokensMap[\"EOF\"] = EOF;\n    const allTokenTypes = has_default(tokenVocabulary, \"modes\") ? flatten_default(values_default(tokenVocabulary.modes)) : values_default(tokenVocabulary);\n    const noTokenCategoriesUsed = every_default(allTokenTypes, (tokenConstructor) => isEmpty_default(tokenConstructor.categoryMatches));\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n    augmentTokenTypes(values_default(this.tokensMap));\n  }\n  defineRule(ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n    }\n    const resyncEnabled = has_default(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = has_default(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    const shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    let invokeRuleWithTry;\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry2(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n    const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n    return wrappedGrammarRule;\n  }\n  invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\n    const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if (isRecognitionException(e)) {\n      const recogError = e;\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc(e);\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        this.moveToTerminatedState();\n        return recoveryValueFunc(e);\n      } else {\n        throw recogError;\n      }\n    } else {\n      throw e;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternal(actionORMethodDef, occurrence) {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n  optionInternalLogic(actionORMethodDef, occurrence, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return void 0;\n  }\n  atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  }\n  atLeastOneSepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterAtLeastOneSepWalker\n      ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  }\n  manyInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookaheadFunction;\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    let notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    );\n  }\n  manySepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  manySepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterManySepWalker\n      ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  }\n  repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n      prodOccurrence,\n      separator,\n      separatorLookAheadFunc,\n      action,\n      nextTerminalAfterWalker\n    ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  }\n  doSingleRepetition(action) {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition();\n    return afterIteration > beforeIteration;\n  }\n  orInternal(altsOrOpts, occurrence) {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    const alts = isArray_default(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== void 0) {\n      const chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  }\n  ruleFinallyStateUpdate() {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  }\n  subruleInternal(ruleToCall, idx, options) {\n    let ruleResult;\n    try {\n      const args = options !== void 0 ? options.ARGS : void 0;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n  subruleInternalError(e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== void 0) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  }\n  consumeInternal(tokType, idx, options) {\n    let consumedToken;\n    try {\n      const nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  }\n  consumeInternalError(tokType, nextToken, options) {\n    let msg;\n    const previousToken = this.LA(0);\n    if (options !== void 0 && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  }\n  consumeInternalRecovery(tokType, idx, eFromConsumption) {\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n  saveRecogState() {\n    const savedErrors = this.errors;\n    const savedRuleStack = clone_default(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  }\n  reloadRecogState(newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  }\n  ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    this.cstInvocationStateUpdate(fullName);\n  }\n  isBackTracking() {\n    return this.isBackTrackingStack.length !== 0;\n  }\n  getCurrRuleFullName() {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n  shortRuleNameToFullName(shortName) {\n    return this.shortRuleNameToFull[shortName];\n  }\n  isAtEndOfInput() {\n    return this.tokenMatcher(this.LA(1), EOF);\n  }\n  reset() {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n};\n\n// lib/src/parse/parser/traits/error_handler.js\nvar ErrorHandler = class {\n  initErrorHandler(config) {\n    this._errors = [];\n    this.errorMessageProvider = has_default(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n  SAVE_ERROR(error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone_default(this.RULE_OCCURRENCE_STACK)\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  }\n  get errors() {\n    return clone_default(this._errors);\n  }\n  set errors(newErrors) {\n    this._errors = newErrors;\n  }\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(occurrence, errMsgTypes) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const previousToken = this.LA(0);\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  }\n};\n\n// lib/src/parse/parser/traits/context_assist.js\nvar ContentAssist = class {\n  initContentAssist() {\n  }\n  computeContentAssist(startRuleName, precedingInput) {\n    const startRuleGast = this.gastProductionsCache[startRuleName];\n    if (isUndefined_default(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n    }\n    return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n  }\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  getNextPossibleTokenTypes(grammarPath) {\n    const topRuleName = head_default(grammarPath.ruleStack);\n    const gastProductions = this.getGAstProductions();\n    const topProduction = gastProductions[topRuleName];\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n    return nextPossibleTokenTypes;\n  }\n};\n\n// lib/src/parse/parser/traits/gast_recorder.js\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\nvar GastRecorder = class {\n  initGastRecorder(config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  }\n  enableRecording() {\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        this[`CONSUME${idx}`] = function(arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        this[`SUBRULE${idx}`] = function(arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        this[`OPTION${idx}`] = function(arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        this[`OR${idx}`] = function(arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        this[`MANY${idx}`] = function(arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        this[`MANY_SEP${idx}`] = function(arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE${idx}`] = function(arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      }\n      this[`consume`] = function(idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      this[`subrule`] = function(idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      this[`option`] = function(idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      this[`or`] = function(idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      this[`many`] = function(idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      this[`atLeastOne`] = function(idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      this.ACTION = this.ACTION_RECORD;\n      this.BACKTRACK = this.BACKTRACK_RECORD;\n      this.LA = this.LA_RECORD;\n    });\n  }\n  disableRecording() {\n    this.RECORDING_PHASE = false;\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that = this;\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        delete that[`CONSUME${idx}`];\n        delete that[`SUBRULE${idx}`];\n        delete that[`OPTION${idx}`];\n        delete that[`OR${idx}`];\n        delete that[`MANY${idx}`];\n        delete that[`MANY_SEP${idx}`];\n        delete that[`AT_LEAST_ONE${idx}`];\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\n      }\n      delete that[`consume`];\n      delete that[`subrule`];\n      delete that[`option`];\n      delete that[`or`];\n      delete that[`many`];\n      delete that[`atLeastOne`];\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  }\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD(impl) {\n  }\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD(grammarRule, args) {\n    return () => true;\n  }\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch) {\n    return END_OF_FILE;\n  }\n  topLevelRuleRecord(name, def) {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n        } catch (mutabilityError) {\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternalRecord(actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  }\n  atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  }\n  atLeastOneSepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  manyInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  }\n  manySepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  orInternalRecord(altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  }\n  subruleInternalRecord(ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has_default(ruleToCall, \"ruleName\") === false) {\n      const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last_default(this.recordingProdStack);\n    const ruleName = ruleToCall.ruleName;\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: void 0\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  }\n  consumeInternalRecord(tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last_default(this.recordingProdStack);\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  }\n};\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last_default(this.recordingProdStack);\n  const grammarAction = isFunction_default(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has_default(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last_default(this.recordingProdStack);\n  const hasOptions = isArray_default(mainProdArg) === false;\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if (has_default(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  const hasPredicates = some_default(alts, (currAlt) => isFunction_default(currAlt.GATE));\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach_default(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] });\n    newOrProd.definition.push(currAltFlat);\n    if (has_default(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } else if (has_default(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(this);\n    this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\n\tIdx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`\n    );\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}\n\n// lib/src/parse/parser/traits/perf_tracer.js\nvar PerformanceTracer = class {\n  initPerformanceTracer(config) {\n    if (has_default(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf;\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\n      this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n      this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n    } else {\n      this.traceInitMaxIdent = 0;\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n    }\n    this.traceInitIndent = -1;\n  }\n  TRACE_INIT(phaseDesc, phaseImpl) {\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  }\n};\n\n// lib/src/parse/parser/utils/apply_mixins.js\nfunction applyMixins(derivedCtor, baseCtors) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return;\n      }\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\n\n// lib/src/parse/parser/parser.js\nvar END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nvar DEFAULT_PARSER_CONFIG = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n});\nvar DEFAULT_RULE_CONFIG = Object.freeze({\n  recoveryValueFunc: () => void 0,\n  resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function(ParserDefinitionErrorType2) {\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value = void 0) {\n  return function() {\n    return value;\n  };\n}\nvar Parser = class _Parser {\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance) {\n    throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n  }\n  performSelfAnalysis() {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n      this.selfAnalysisDone = true;\n      const className = this.className;\n      this.TRACE_INIT(\"toFastProps\", () => {\n        toFastProperties(this);\n      });\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording();\n          forEach_default(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = this[currRuleName];\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n      let resolverErrors = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar2({\n          rules: values_default(this.gastProductionsCache)\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        if (isEmpty_default(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar2({\n            rules: values_default(this.gastProductionsCache),\n            tokenTypes: values_default(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          });\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values_default(this.gastProductionsCache),\n            tokenTypes: values_default(this.tokensMap),\n            grammarName: className\n          });\n          this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n        }\n      });\n      if (isEmpty_default(this.definitionErrors)) {\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(values_default(this.gastProductionsCache));\n            this.resyncFollows = allFollows;\n          });\n        }\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          var _a, _b;\n          (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            rules: values_default(this.gastProductionsCache)\n          });\n          this.preComputeLookaheadFunctions(values_default(this.gastProductionsCache));\n        });\n      }\n      if (!_Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty_default(this.definitionErrors)) {\n        defErrorsMsgs = map_default(this.definitionErrors, (defError) => defError.message);\n        throw new Error(`Parser Definition Errors detected:\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n      }\n    });\n  }\n  constructor(tokenVocabulary, config) {\n    this.definitionErrors = [];\n    this.selfAnalysisDone = false;\n    const that = this;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n    if (has_default(config, \"ignoredIssues\")) {\n      throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n    }\n    this.skipValidations = has_default(config, \"skipValidations\") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n};\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n]);\nvar CstParser = class extends Parser {\n  constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n    const configClone = clone_default(config);\n    configClone.outputCst = true;\n    super(tokenVocabulary, configClone);\n  }\n};\nvar EmbeddedActionsParser = class extends Parser {\n  constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n    const configClone = clone_default(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n};\n\n// ../cst-dts-gen/lib/src/model.js\nfunction buildModel(productions) {\n  const generator = new CstNodeDefinitionGenerator();\n  const allRules = values_default(productions);\n  return map_default(allRules, (rule) => generator.visitRule(rule));\n}\nvar CstNodeDefinitionGenerator = class extends GAstVisitor {\n  visitRule(node) {\n    const rawElements = this.visitEach(node.definition);\n    const grouped = groupBy_default(rawElements, (el) => el.propertyName);\n    const properties = map_default(grouped, (group, propertyName) => {\n      const allNullable = !some_default(group, (el) => !el.canBeNull);\n      let propertyType = group[0].type;\n      if (group.length > 1) {\n        propertyType = map_default(group, (g) => g.type);\n      }\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      };\n    });\n    return {\n      name: node.name,\n      properties\n    };\n  }\n  visitAlternative(node) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n  visitOption(node) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n  visitRepetition(node) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n  visitRepetitionMandatory(node) {\n    return this.visitEach(node.definition);\n  }\n  visitRepetitionMandatoryWithSeparator(node) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  }\n  visitRepetitionWithSeparator(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  }\n  visitAlternation(node) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n  visitTerminal(node) {\n    return [\n      {\n        propertyName: node.label || node.terminalType.name,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ];\n  }\n  visitNonTerminal(node) {\n    return [\n      {\n        propertyName: node.label || node.nonTerminalName,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ];\n  }\n  visitEachAndOverrideWith(definition, override) {\n    return map_default(this.visitEach(definition), (definition2) => assign_default({}, definition2, override));\n  }\n  visitEach(definition) {\n    return flatten_default(map_default(definition, (definition2) => this.visit(definition2)));\n  }\n};\nfunction getType(production) {\n  if (production instanceof NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    };\n  }\n  return { kind: \"token\" };\n}\n\n// ../cst-dts-gen/lib/src/generate.js\nfunction genDts(model, options) {\n  let contentParts = [];\n  contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`);\n  contentParts = contentParts.concat(flatten_default(map_default(model, (node) => genCstNodeTypes(node))));\n  if (options.includeVisitorInterface) {\n    contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));\n  }\n  return contentParts.join(\"\\n\\n\") + \"\\n\";\n}\nfunction genCstNodeTypes(node) {\n  const nodeCstInterface = genNodeInterface(node);\n  const nodeChildrenInterface = genNodeChildrenType(node);\n  return [nodeCstInterface, nodeChildrenInterface];\n}\nfunction genNodeInterface(node) {\n  const nodeInterfaceName = getNodeInterfaceName(node.name);\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n  return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`;\n}\nfunction genNodeChildrenType(node) {\n  const typeName = getNodeChildrenTypeName(node.name);\n  return `export type ${typeName} = {\n  ${map_default(node.properties, (property2) => genChildProperty(property2)).join(\"\\n  \")}\n};`;\n}\nfunction genChildProperty(prop) {\n  const typeName = buildTypeString(prop.type);\n  return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`;\n}\nfunction genVisitor(name, nodes) {\n  return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${map_default(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`;\n}\nfunction genVisitorFunction(node) {\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n  return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;\n}\nfunction buildTypeString(type) {\n  if (isArray_default(type)) {\n    const typeNames = uniq_default(map_default(type, (t) => getTypeString(t)));\n    const typeString = reduce_default(typeNames, (sum, t) => sum + \" | \" + t);\n    return \"(\" + typeString + \")\";\n  } else {\n    return getTypeString(type);\n  }\n}\nfunction getTypeString(type) {\n  if (type.kind === \"token\") {\n    return \"IToken\";\n  }\n  return getNodeInterfaceName(type.name);\n}\nfunction getNodeInterfaceName(ruleName) {\n  return upperFirst_default(ruleName) + \"CstNode\";\n}\nfunction getNodeChildrenTypeName(ruleName) {\n  return upperFirst_default(ruleName) + \"CstChildren\";\n}\n\n// ../cst-dts-gen/lib/src/api.js\nvar defaultOptions = {\n  includeVisitorInterface: true,\n  visitorInterfaceName: \"ICstNodeVisitor\"\n};\nfunction generateCstDts(productions, options) {\n  const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);\n  const model = buildModel(productions);\n  return genDts(model, effectiveOptions);\n}\n\n// lib/src/diagrams/render_public.js\nfunction createSyntaxDiagramsCode(grammar, { resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`, css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css` } = {}) {\n  const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`;\n  const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`;\n  const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'><\\/script>\n<script src='${resourceBase}src/diagrams_builder.js'><\\/script>\n<script src='${resourceBase}src/diagrams_behavior.js'><\\/script>\n<script src='${resourceBase}src/main.js'><\\/script>\n`;\n  const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`;\n  const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n<\\/script>\n`;\n  const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\\/script>\n`;\n  return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;\n}\n\n// lib/src/api.js\nfunction clearCache() {\n  console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\\n\t It performs no action other than printing this message.\\n\t Please avoid using it as it will be completely removed in the future\");\n}\nvar Parser2 = class {\n  constructor() {\n    throw new Error(\"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\t\\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\");\n  }\n};\n\n/*! Bundled license information:\n\nlodash-es/lodash.js:\n  (**\n   * @license\n   * Lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"es\" -o ./`\n   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   *)\n*/\n//# sourceMappingURL=chevrotain.mjs.map\n\n\n//# sourceURL=webpack:///./parser/chevrotain.js?");

/***/ }),

/***/ "./parser/group-parser.js":
/*!********************************!*\
  !*** ./parser/group-parser.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   groupParser: () => (/* binding */ groupParser)\n/* harmony export */ });\n/* harmony import */ var _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chevrotain.js */ \"./parser/chevrotain.js\");\n/* harmony import */ var _group_stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group-stack.js */ \"./parser/group-stack.js\");\n/* harmony import */ var _lexer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lexer.js */ \"./parser/lexer.js\");\n\r\n\r\n\r\n\r\n\r\nclass GroupParser extends _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.EmbeddedActionsParser {\r\n  constructor() {\r\n    super(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.allTokens);\r\n    const $ = this;\r\n\r\n    $.RULE(\"Form\", () => {\r\n      let result = {\r\n        name: \"Form\",\r\n        children: { Items: [], FormHeader: [] },\r\n      };\r\n\r\n      let group_stack = new _group_stack_js__WEBPACK_IMPORTED_MODULE_1__.GroupStack(result);\r\n\r\n      $.SUBRULE($.Lines, { ARGS: [group_stack] });\r\n\r\n      return result;\r\n    });\r\n\r\n    $.RULE(\"Lines\", (group_stack) => {\r\n      let isFirst = true;\r\n      $.MANY(() => {\r\n        // let indent = $.SUBRULE($.Indents);\r\n        $.OR([\r\n          {\r\n            GATE: () => {\r\n              return isFirst;\r\n            },\r\n            ALT: () => {\r\n              let header = $.SUBRULE1($.FormHeader);\r\n              if (!$.RECORDING_PHASE) {\r\n                group_stack.form.children.FormHeader.push(header);\r\n              }\r\n              isFirst = false;\r\n            },\r\n          },\r\n          // {\r\n          //   ALT: () => {\r\n          //     $.CONSUME3(t.NewLine);\r\n\r\n          //   },\r\n          // },\r\n          {\r\n            ALT: () => {\r\n              isFirst = false;\r\n              $.SUBRULE($.Line, { ARGS: [group_stack] });\r\n            },\r\n          },\r\n        ]);\r\n      });\r\n    });\r\n\r\n    // ---Заголовок формы---\r\n    $.RULE(\"FormHeader\", () => {\r\n      let result = {\r\n        name: \"FormHeader\",\r\n        children: { Dash: [], Text: [] },\r\n      };\r\n\r\n      result.children.Dash.push($.CONSUME1(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.TripleDash));\r\n\r\n      $.MANY(() => {\r\n        result.children.Text.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.HeaderText));\r\n      });\r\n\r\n      result.children.Dash.push($.CONSUME7(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.TripleDash));\r\n\r\n      $.OPTION({\r\n        GATE: () => {\r\n          return $.LA(1).tokenType != _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.EOF;\r\n        },\r\n        DEF: () => {\r\n          return $.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.NewLine);\r\n        },\r\n      });\r\n\r\n      return result;\r\n    });\r\n\r\n    // #Заголовок 1\r\n    $.RULE(\"VGroupHeader\", () => {\r\n      let result = {\r\n        name: \"VGroupHeader\",\r\n        children: { Hash: [], Text: [], Properties: {} },\r\n      };\r\n\r\n      $.AT_LEAST_ONE(() => {\r\n        result.children.Hash.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.Hash));\r\n      });\r\n\r\n      $.MANY(() => {\r\n        result.children.Text.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.PageGroupHeaderText));\r\n      });\r\n\r\n      let propertiesObj = $.SUBRULE($.Properties);\r\n\r\n      if (propertiesObj.isProperties) {\r\n        result.children.Properties = propertiesObj.properties;\r\n      } else {\r\n        result.children.Text = result.children.Text.concat(\r\n          propertiesObj.tokens\r\n        );\r\n      }\r\n\r\n      return result;\r\n    });\r\n\r\n    // /Заголовок страницы\r\n    $.RULE(\"PageHeader\", () => {\r\n      let result = {\r\n        name: \"PageHeader\",\r\n        children: { Slash: [], Text: [], Properties: {} },\r\n      };\r\n\r\n      result.children.Slash.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.Slash));\r\n\r\n      $.MANY(() => {\r\n        result.children.Text.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.PageGroupHeaderText));\r\n      });\r\n\r\n      let propertiesObj = $.SUBRULE($.Properties);\r\n\r\n      if (propertiesObj.isProperties) {\r\n        result.children.Properties = propertiesObj.properties;\r\n      } else {\r\n        result.children.Text = result.children.Text.concat(\r\n          propertiesObj.tokens\r\n        );\r\n      }\r\n\r\n      return result;\r\n    });\r\n\r\n    $.RULE(\"Properties\", () => {\r\n      let result = {\r\n        properties: {},\r\n        tokens: [],\r\n        isProperties: false,\r\n        isPropertiesCounter: 0,\r\n      };\r\n\r\n      $.OPTION1(() => {\r\n        result.tokens.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.LCurly));\r\n        result.isPropertiesCounter++;\r\n      });\r\n\r\n      $.OPTION2(() => {\r\n        $.SUBRULE1($.Property, { ARGS: [result] });\r\n        // $.MANY1(() => {\r\n        //   result.tokens.push($.CONSUME(Comma));\r\n        //   $.SUBRULE2($.Property, { ARGS: [result] });\r\n        // });\r\n      });\r\n\r\n      $.OPTION3(() => {\r\n        result.tokens.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.RCurly));\r\n        result.isPropertiesCounter++;\r\n        $.MANY2(() => {\r\n          result.isPropertiesCounter = 0;\r\n          result.tokens.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.PageGroupHeaderText));\r\n        });\r\n      });\r\n\r\n      result.isProperties = result.isPropertiesCounter > 1;\r\n\r\n      return result;\r\n    });\r\n\r\n    $.RULE(\"Property\", (params) => {\r\n      let tokens = [];\r\n      if (!$.RECORDING_PHASE) {\r\n        tokens = params.tokens;\r\n      }\r\n\r\n      let isPropertiesCounter = 0;\r\n      let key, value;\r\n      $.OPTION1(() => {\r\n        key = $.CONSUME1(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.PropertiesNameText);\r\n        tokens.push(key);\r\n        isPropertiesCounter++;\r\n      });\r\n\r\n      $.OPTION2(() => {\r\n        tokens.push($.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.Equals));\r\n        isPropertiesCounter++;\r\n      });\r\n\r\n      $.OPTION3(() => {\r\n        value = $.CONSUME2(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.PropertiesValueText);\r\n        tokens.push(value);\r\n        isPropertiesCounter++;\r\n      });\r\n\r\n      if (!$.RECORDING_PHASE) {\r\n        if (isPropertiesCounter < 3) {\r\n          params.isPropertiesCounter = 0;\r\n        } else {\r\n          params.properties[key.image] = value.image;\r\n        }\r\n      }\r\n    });\r\n\r\n    $.RULE(\"Indents\", () => {\r\n      let indent = 0;\r\n      $.MANY(() => {\r\n        $.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.Tab);\r\n        if (!$.RECORDING_PHASE) {\r\n          indent++;\r\n        }\r\n      });\r\n      return indent;\r\n    });\r\n\r\n    $.RULE(\"OneLineGroup\", (group_stack, indent, firstInline) => {\r\n      let result;\r\n      if (!$.RECORDING_PHASE) {\r\n        result = group_stack.createOneLineGroup();\r\n\r\n        group_stack.setParent(firstInline, result);\r\n        // inline.children.Items.push(first);\r\n      }\r\n\r\n      $.MANY({\r\n        SEP: _lexer_js__WEBPACK_IMPORTED_MODULE_2__.Ampersand,\r\n        DEF: () => {\r\n          let item = this.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.InlineText);\r\n          if (!$.RECORDING_PHASE) {\r\n            let inline = group_stack.createInline(result);\r\n            group_stack.setParent(inline, result);\r\n            inline.children.Items.push(item);\r\n          }\r\n        },\r\n      });\r\n      return result;\r\n    });\r\n\r\n    $.RULE(\"Inline\", (group_stack, indent) => {\r\n      let item;\r\n      if (!$.RECORDING_PHASE) {\r\n        item = group_stack.createInline();\r\n      }\r\n\r\n      $.AT_LEAST_ONE(() => {\r\n        let inlineText = this.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.InlineText);\r\n        if (!$.RECORDING_PHASE) {\r\n          item.children.Items.push(inlineText);\r\n        }\r\n      });\r\n\r\n      $.OPTION(() => {\r\n        $.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.Ampersand);\r\n        item = $.SUBRULE($.OneLineGroup, {\r\n          ARGS: [group_stack, indent, item],\r\n        });\r\n      });\r\n\r\n      if (!$.RECORDING_PHASE) {\r\n        group_stack.add(item, indent);\r\n      }\r\n    });\r\n\r\n    $.RULE(\"Column\", (group_stack, indent) => {\r\n      // let indent = $.SUBRULE($.Indents);\r\n\r\n      $.OR([\r\n        {\r\n          // #Подзаголовок 1 #Подзаголовок 2\r\n          ALT: () => {\r\n            $.AT_LEAST_ONE(() => {\r\n              let header = $.SUBRULE($.VGroupHeader);\r\n\r\n              if (!$.RECORDING_PHASE) {\r\n                group_stack.add(header, indent);\r\n              }\r\n            });\r\n          },\r\n        },\r\n        // /Страница\r\n        {\r\n          ALT: () => {\r\n            let header = $.SUBRULE($.PageHeader);\r\n\r\n            if (!$.RECORDING_PHASE) {\r\n              group_stack.add(header, indent);\r\n            }\r\n          },\r\n        },\r\n        // Строчный элемент\r\n        {\r\n          ALT: () => {\r\n            $.SUBRULE($.Inline, { ARGS: [group_stack, indent] });\r\n          },\r\n        },\r\n      ]);\r\n    });\r\n\r\n    $.RULE(\"Line\", (group_stack) => {\r\n      $.AT_LEAST_ONE_SEP({\r\n        SEP: _lexer_js__WEBPACK_IMPORTED_MODULE_2__.Plus,\r\n        DEF: () => {\r\n          let indent = $.SUBRULE($.Indents);\r\n\r\n          $.OPTION2(() => {\r\n            $.SUBRULE2($.Column, { ARGS: [group_stack, indent] });\r\n          });\r\n\r\n          if (!$.RECORDING_PHASE) {\r\n            group_stack.next();\r\n          }\r\n        },\r\n      });\r\n\r\n      $.OPTION3({\r\n        GATE: () => {\r\n          return $.LA(1).tokenType != _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.EOF;\r\n        },\r\n        DEF: () => {\r\n          return $.CONSUME(_lexer_js__WEBPACK_IMPORTED_MODULE_2__.NewLine);\r\n        },\r\n      });\r\n\r\n      if (!$.RECORDING_PHASE) {\r\n        group_stack.doneLine();\r\n      }\r\n    });\r\n\r\n    this.performSelfAnalysis();\r\n  }\r\n}\r\n\r\n\r\nconst groupParser = new GroupParser();\r\n\n\n//# sourceURL=webpack:///./parser/group-parser.js?");

/***/ }),

/***/ "./parser/group-stack.js":
/*!*******************************!*\
  !*** ./parser/group-stack.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupStack: () => (/* binding */ GroupStack)\n/* harmony export */ });\nclass GroupStack {\r\n  constructor(form) {\r\n    this.form = form;\r\n    this.reset();\r\n  }\r\n\r\n  next() {\r\n    this.index++;\r\n    this.setCurrentParent(this.getPrevAtIndex());\r\n  }\r\n\r\n  getCurrentParent() {\r\n    return this.currentParent;\r\n  }\r\n\r\n  setCurrentParent(parent) {\r\n    this.currentParent = parent;\r\n  }\r\n\r\n  doneLine() {\r\n    for (let index = this.index; index <= this.prevGroups.length - 1; index++) {\r\n      let item = this.prevGroups[index];\r\n      this.currentGroups.push(item);\r\n    }\r\n\r\n    this.prevGroups = this.currentGroups.slice();\r\n    this.currentGroups = [];\r\n    this.index = 0;\r\n    this.setCurrentParent(this.getPrevAtIndex());\r\n  }\r\n\r\n  getPrevAtIndex() {\r\n    if (this.index >= this.prevGroups.length) {\r\n      if (this.prevGroups.length > 0) {\r\n        return this.prevGroups[this.prevGroups.length - 1];\r\n      }\r\n      return this.form;\r\n    }\r\n    return this.prevGroups[this.index];\r\n  }\r\n\r\n  getItemAtIndent(current, indent) {\r\n    let resultIndent = this.getIndent(current);\r\n\r\n    if (indent >= resultIndent) {\r\n      return current;\r\n    }\r\n\r\n    let result = current;\r\n    while (resultIndent > indent) {\r\n      result = this.getParent(result);\r\n      resultIndent = this.getIndent(parent);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  getIndent(item) {\r\n    return this.indents.get(item);\r\n  }\r\n\r\n  getParent(item) {\r\n    const parent = this.parents.get(item);\r\n    if (parent === undefined) {\r\n      return this.form;\r\n    }\r\n    return parent;\r\n  }\r\n\r\n  add(item, indent) {\r\n    let prevGroup = this.getCurrentParent();\r\n    let parent = this.getItemAtIndent(prevGroup, indent);\r\n    let curIndent = this.getIndent(parent);\r\n\r\n    if (this.addPage(item, parent, curIndent)) {\r\n      return;\r\n    }\r\n\r\n    if (this.addGroup(item, parent, curIndent)) {\r\n      return;\r\n    }    \r\n\r\n    //Если текущий элемент на этом уровне - страницы, значит они закончились и обращаемся к их родителю\r\n    if (parent.name == \"Pages\") {\r\n      parent = this.getParent(parent);\r\n    }\r\n\r\n    // Обычный элемент\r\n    this.setParent(item, parent);\r\n    this.currentGroups.push(parent);\r\n  }\r\n\r\n  addPage(item, parent, indent) {\r\n    if (item.name != \"PageHeader\") {\r\n      return false;\r\n    }\r\n\r\n    // Если это первая страница - создаем группу\r\n    if (parent.name != \"Pages\") {\r\n      const pages = this.getNewPages();\r\n      // parent.children.Items.push(pages);\r\n      this.setParent(pages, parent);\r\n      this.setIndent(pages, indent);\r\n      parent = pages;\r\n    }\r\n\r\n    const page = this.getNewPage(item);\r\n    page.children.Properties = item.children.Properties;\r\n\r\n    this.setParent(page, parent);\r\n    this.setIndent(page, indent + 1);\r\n    this.currentGroups.push(page);\r\n    return true;\r\n  }\r\n\r\n  addGroup(item, parent, indent) {\r\n    if (item.name != \"VGroupHeader\") {\r\n      return false;\r\n    }\r\n \r\n    // Правила отступов для групп следующие \r\n    // - отступ первой вертикальной группы совпадает с отступом родителя\r\n    // - отступ каждой следующей вертикальной группы - всегда 0\r\n    let vGroupIndent = 0;\r\n\r\n    if (parent.name != \"HGroup\") {\r\n      const hGroup = this.getNewHGroup();\r\n      this.setParent(hGroup, parent);\r\n      this.setIndent(hGroup, indent);\r\n      this.setCurrentParent(hGroup);\r\n      vGroupIndent = indent;\r\n      parent = hGroup;\r\n    }\r\n\r\n    const group = this.getNewVGroup(item);\r\n    group.children.Properties = item.children.Properties;\r\n    this.setParent(group, parent);\r\n    this.setIndent(group, vGroupIndent);\r\n    this.currentGroups.push(group);\r\n    return true;\r\n  }\r\n\r\n  // getInline(parent, item) {\r\n  //   if (item.name == \"OneLineGroup\") {\r\n  //     return parent;\r\n  //   }\r\n\r\n  //   // const len = parent.children.Items.length;\r\n  //   // if (len == 0) {\r\n  //   //   let inline = this.createInline();\r\n  //   //   this.setParent(inline, parent);\r\n  //   //   return inline;\r\n  //   // }\r\n\r\n  //   // const parentInline = parent.children.Items[len - 1];\r\n  //   // Сейчас каждый раз создаем новый, когда будет полный парсер - будем собирать в один\r\n  //   // if (parentInline.name != \"Inline\") {\r\n  //   let inline = this.createInline();\r\n  //   this.setParent(inline, parent);\r\n  //   return inline;\r\n  //   // }\r\n  //   // return parentInline;\r\n  // }\r\n\r\n  // processEmptyLine() {\r\n  //   let prevGroup = this.getCurrentParent();\r\n\r\n  //   while (prevGroup.name != \"Page\" && prevGroup.name != \"Form\") {\r\n  //     prevGroup = this.getParent(prevGroup);\r\n  //   }\r\n\r\n  //   this.currentGroups.push(prevGroup);\r\n  //   this.prevGroups = [];\r\n\r\n  //   let inline = this.createInline();\r\n  //   this.setParent(inline, prevGroup);\r\n\r\n  //   this.doneLine();\r\n  // }\r\n\r\n  reset() {\r\n    this.prevGroups = [];\r\n    this.currentGroups = [];\r\n    this.index = 0;\r\n\r\n    this.parents = new WeakMap();\r\n    this.indents = new WeakMap();\r\n    this.setIndent(this.form, 0);\r\n\r\n    this.currentParent = this.form;\r\n  }\r\n\r\n  setIndent(item, indent) {\r\n    this.indents.set(item, indent);\r\n  }\r\n\r\n  setParent(item, parent) {\r\n    this.parents.set(item, parent);\r\n    parent.children.Items.push(item);\r\n  }\r\n\r\n  getNewVGroup(header) {\r\n    const group = {\r\n      name: \"VGroup\",\r\n      children: { VGroupHeader: [], Items: [], Properties: {} },\r\n    };\r\n\r\n    if (header !== undefined) {\r\n      group.children.VGroupHeader.push(header);\r\n    }\r\n\r\n    return group;\r\n  }\r\n\r\n  getNewHGroup() {\r\n    const group = {\r\n      name: \"HGroup\",\r\n      children: { Items: [], Properties: {} },\r\n    };\r\n\r\n    return group;\r\n  }\r\n\r\n  getNewPage(header) {\r\n    const page = {\r\n      name: \"Page\",\r\n      children: { PageHeader: [header], Items: [], Properties: {} },\r\n    };\r\n    return page;\r\n  }\r\n\r\n  getNewPages() {\r\n    const page = {\r\n      name: \"Pages\",\r\n      children: { Items: [] },\r\n    };\r\n    return page;\r\n  }\r\n\r\n  createOneLineGroup() {\r\n    const result = {\r\n      name: \"OneLineGroup\",\r\n      children: { Items: [] },\r\n    };\r\n    return result;\r\n  }\r\n\r\n  createInline() {\r\n    const inline = {\r\n      name: \"Inline\",\r\n      children: { Items: [] },\r\n    };\r\n    return inline;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./parser/group-stack.js?");

/***/ }),

/***/ "./parser/lexer.js":
/*!*************************!*\
  !*** ./parser/lexer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ampersand: () => (/* binding */ Ampersand),\n/* harmony export */   Dash: () => (/* binding */ Dash),\n/* harmony export */   Equals: () => (/* binding */ Equals),\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   HeaderText: () => (/* binding */ HeaderText),\n/* harmony export */   InlineText: () => (/* binding */ InlineText),\n/* harmony export */   LCurly: () => (/* binding */ LCurly),\n/* harmony export */   NewLine: () => (/* binding */ NewLine),\n/* harmony export */   PageGroupHeaderText: () => (/* binding */ PageGroupHeaderText),\n/* harmony export */   Plus: () => (/* binding */ Plus),\n/* harmony export */   PropertiesNameText: () => (/* binding */ PropertiesNameText),\n/* harmony export */   PropertiesValueText: () => (/* binding */ PropertiesValueText),\n/* harmony export */   RCurly: () => (/* binding */ RCurly),\n/* harmony export */   Semicolon: () => (/* binding */ Semicolon),\n/* harmony export */   Slash: () => (/* binding */ Slash),\n/* harmony export */   Tab: () => (/* binding */ Tab),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TripleDash: () => (/* binding */ TripleDash),\n/* harmony export */   Whitespace: () => (/* binding */ Whitespace),\n/* harmony export */   allTokens: () => (/* binding */ allTokens),\n/* harmony export */   lexer: () => (/* binding */ lexer)\n/* harmony export */ });\n/* harmony import */ var _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chevrotain.js */ \"./parser/chevrotain.js\");\n\r\n\r\nconst HeaderText = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"HeaderText\",\r\n  pattern: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA,\r\n});\r\n\r\nconst PropertiesNameText = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"PropertiesNameText\",\r\n  pattern: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA,\r\n});\r\n\r\nconst PropertiesValueText = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"PropertiesValueText\",\r\n  pattern: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA,\r\n});\r\n\r\nconst PageGroupHeaderText = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"PageGroupHeaderText\",\r\n  pattern: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA,\r\n});\r\n\r\nconst InlineText = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"InlineText\",\r\n  pattern: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA,\r\n});\r\n\r\nconst LCurly = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"LCurly\",\r\n  pattern: /{ */,\r\n  label: \"{\",\r\n  categories: [HeaderText, InlineText, PropertiesValueText],\r\n});\r\nconst RCurly = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"RCurly\",\r\n  pattern: /} */,\r\n  label: \"}\",\r\n  categories: [HeaderText, InlineText, PageGroupHeaderText],\r\n});\r\nconst Semicolon = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Semicolon\",\r\n  pattern: /\\; */,\r\n  label: \";\",\r\n  categories: [\r\n    HeaderText,\r\n    InlineText,\r\n    PageGroupHeaderText,\r\n    PropertiesValueText,\r\n  ],\r\n});\r\n// const Comma = createToken({\r\n//   name: \"Comma\",\r\n//   pattern: /\\,/,\r\n//   label: \",\",\r\n//   categories: [Header, InlineText],\r\n// });\r\nconst Equals = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Equals\",\r\n  pattern: /\\= */,\r\n  label: \"=\",\r\n  categories: [HeaderText, InlineText, PageGroupHeaderText],\r\n});\r\nconst Hash = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Hash\",\r\n  pattern: /# */,\r\n  label: \"#\",\r\n  categories: [HeaderText],\r\n});\r\nconst Plus = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Plus\",\r\n  pattern: /\\+ */,\r\n  label: \"+\",\r\n  categories: [HeaderText],\r\n});\r\nconst TripleDash = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"TripleDash\",\r\n  pattern: /---[ \\t]*/,\r\n  label: \"---\",\r\n  categories: [InlineText, PageGroupHeaderText, PropertiesValueText],\r\n});\r\n\r\nconst Dash = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Dash\",\r\n  pattern: /-[ \\t]*/,\r\n  label: \"-\",\r\n  categories: [InlineText, PageGroupHeaderText, PropertiesValueText],\r\n  longer_alt: TripleDash,\r\n});\r\n\r\nconst Slash = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Slash\",\r\n  pattern: /\\/ */,\r\n  label: \"/\",\r\n  categories: [HeaderText, PageGroupHeaderText, PropertiesValueText],\r\n});\r\nconst Ampersand = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Ampersand\",\r\n  pattern: /\\& */,\r\n  label: \"&\",\r\n  categories: [HeaderText, PageGroupHeaderText, PropertiesValueText],\r\n});\r\nconst Tab = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({ name: \"Tab\", pattern: /\\t/ });\r\n\r\nconst Text = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Text\",\r\n  pattern: /[^\\{\\}\\=\\;\\&\\#\\+\\n\\r\\t\\/\\- ][^\\{\\}\\=\\;\\&\\#\\+\\n\\r\\t\\-]*/,\r\n  categories: [\r\n    HeaderText,\r\n    InlineText,\r\n    PageGroupHeaderText,\r\n    PropertiesNameText,\r\n    PropertiesValueText,\r\n  ],\r\n});\r\n\r\nconst NewLine = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"NewLine\",\r\n  pattern: /\\n/,\r\n  line_breaks: true,\r\n  group_stock: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.SKIPPED,\r\n});\r\n\r\nconst Whitespace = (0,_chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.createToken)({\r\n  name: \"Whitespace\",\r\n  pattern: /s+/,\r\n  group_stock: _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.SKIPPED,\r\n});\r\n\r\nconst allTokens = [\r\n  Whitespace,\r\n  Dash,\r\n  TripleDash,\r\n  Text,\r\n  NewLine,\r\n  LCurly,\r\n  RCurly,\r\n  Semicolon,\r\n  Equals,\r\n  Hash,\r\n  Ampersand,\r\n  Plus,\r\n  Slash,\r\n  Tab,\r\n  HeaderText,\r\n  InlineText,\r\n  PageGroupHeaderText,\r\n  PropertiesNameText,\r\n  PropertiesValueText\r\n];\r\n\r\nconst lexer = new _chevrotain_js__WEBPACK_IMPORTED_MODULE_0__.Lexer(allTokens);\n\n//# sourceURL=webpack:///./parser/lexer.js?");

/***/ }),

/***/ "./parser/visitor.js":
/*!***************************!*\
  !*** ./parser/visitor.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   visitor: () => (/* binding */ visitor)\n/* harmony export */ });\n/* harmony import */ var _group_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group-parser.js */ \"./parser/group-parser.js\");\n\r\n\r\nconst BaseVisitor = _group_parser_js__WEBPACK_IMPORTED_MODULE_0__.groupParser.getBaseCstVisitorConstructor();\r\n\r\nclass Visitor extends BaseVisitor {\r\n  Form(ctx) {\r\n    let result = {\r\n      Тип: \"Форма\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ЭлементыПарсинг: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    let header = this.visit(ctx.FormHeader);\r\n    if (header !== undefined) {\r\n      result.НаборСвойств.Заголовок = this.visit(ctx.FormHeader);\r\n    }\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.ЭлементыПарсинг.push(this.visit(item));\r\n    });\r\n\r\n    this.addChildLocation(result.ЭлементыПарсинг, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  FormHeader(ctx) {\r\n    return ctx.Text.map((token) => token.image)\r\n      .join(\"\")\r\n      .trim();\r\n  }\r\n\r\n  PageHeader(ctx) {\r\n    return ctx.Text.map((token) => token.image)\r\n      .join(\"\")\r\n      .trim();\r\n  }\r\n\r\n  VGroupHeader(ctx) {\r\n    return ctx.Text[0].image.trim();\r\n  }\r\n\r\n  HGroup(ctx) {\r\n    let result = {\r\n      Тип: \"ГоризонтальнаяГруппа\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.Элементы.push(this.visit(item));\r\n    });\r\n\r\n    this.addChildLocation(result.Элементы, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  VGroup(ctx) {\r\n    let result = {\r\n      Тип: \"ВертикальнаяГруппа\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ЭлементыПарсинг: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    for (const [key, value] of Object.entries(ctx.Properties)) {\r\n      result.НаборСвойств[key.trim()] = value.trim();\r\n    }\r\n\r\n    result.НаборСвойств.Заголовок = this.visit(ctx.VGroupHeader);\r\n\r\n    this.addDisplayAndBehaviorToGroup(result[\"НаборСвойств\"], ctx.VGroupHeader);\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.ЭлементыПарсинг.push(this.visit(item));\r\n    });\r\n\r\n    if (ctx.VGroupHeader.length > 0) {\r\n      this.consumeLocation(ctx.VGroupHeader[0].children.Hash, result);\r\n      this.consumeLocation(ctx.VGroupHeader[0].children.Text, result);\r\n    }\r\n\r\n    this.addChildLocation(result.ЭлементыПарсинг, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  addDisplayAndBehaviorToGroup(properties, VGroupHeader) {\r\n    if (VGroupHeader.length == 0) {\r\n      return;\r\n    }\r\n\r\n    const count = VGroupHeader[0].children.Hash.length;\r\n    let currentDisplay;\r\n    let currentBehavior;\r\n\r\n    if (count === 2) {\r\n      currentDisplay = \"СлабоеВыделение\";\r\n    } else if (count === 3) {\r\n      currentDisplay = \"ОбычноеВыделение\";\r\n    } else if (count === 4) {\r\n      currentDisplay = \"СильноеВыделение\";\r\n    } else if (count === 5) {\r\n      if (!properties.hasOwnProperty(\"Отображение\")) {\r\n        currentDisplay = \"ОбычноеВыделение\";\r\n      }\r\n      currentBehavior = \"Свертываемая\";\r\n    } else if (count === 6) {\r\n      if (!properties.hasOwnProperty(\"Отображение\")) {\r\n        currentDisplay = \"ОбычноеВыделение\";\r\n      }\r\n      currentBehavior = \"Всплывающая\";\r\n    }\r\n\r\n    if (currentDisplay !== undefined) {\r\n      properties[\"Отображение\"] = currentDisplay;\r\n    }\r\n\r\n    if (currentBehavior !== undefined) {\r\n      properties[\"Поведение\"] = currentBehavior;\r\n    }\r\n  }\r\n\r\n  Pages(ctx) {\r\n    let result = {\r\n      Тип: \"Страницы\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.Элементы.push(this.visit(item));\r\n    });\r\n\r\n    this.addChildLocation(result.Элементы, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  Page(ctx) {\r\n    let result = {\r\n      Тип: \"Страница\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ЭлементыПарсинг: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    for (const [key, value] of Object.entries(ctx.Properties)) {\r\n      result.НаборСвойств[key.trim()] = value.trim();\r\n    }\r\n\r\n    result.НаборСвойств.Заголовок = this.visit(ctx.PageHeader);\r\n\r\n    if (ctx.PageHeader.length > 0) {\r\n      this.consumeLocation(ctx.PageHeader[0].children.Slash, result);\r\n      this.consumeLocation(ctx.PageHeader[0].children.Text, result);\r\n    }\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.ЭлементыПарсинг.push(this.visit(item));\r\n    });\r\n\r\n    this.addChildLocation(result.ЭлементыПарсинг, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  OneLineGroup(ctx) {\r\n    let result = {\r\n      Тип: \"ОднострочнаяГруппа\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      Элементы: [],\r\n      ЭлементыПарсинг: [],\r\n      Координаты: {},\r\n    };\r\n\r\n    ctx.Items.forEach((item) => {\r\n      result.ЭлементыПарсинг.push(this.visit(item));\r\n    });\r\n\r\n    this.addChildLocation(result.ЭлементыПарсинг, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  Inline(ctx) {\r\n    let result = {\r\n      Тип: \"СтрочныйЭлемент\",\r\n      // УИД: self.crypto.randomUUID(),\r\n      НаборСвойств: {},\r\n      ЭлементыПарсинг: [],\r\n      ТипыСвойств: {},\r\n      Координаты: {},\r\n    };\r\n\r\n    result.ЭлементыПарсинг = [ctx.Items.map((token) => token.image).join(\"\")];\r\n\r\n    this.consumeLocation(ctx.Items, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  addChildLocation(childs, result) {\r\n    childs.forEach((item) => {\r\n      for (const [key, value] of Object.entries(item.Координаты)) {\r\n        this.consumeLocationInResult(\r\n          result,\r\n          key,\r\n          value[\"Лево\"],\r\n          value[\"Право\"]\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  consumeLocation(tokens, result) {\r\n    tokens.forEach((token) => {\r\n      let rowId = \"Строка_\" + token.startLine.toString();\r\n      this.consumeLocationInResult(\r\n        result,\r\n        rowId,\r\n        token.startColumn,\r\n        token.endColumn\r\n      );\r\n    });\r\n  }\r\n\r\n  consumeLocationInResult(result, rowId, startColumn, endColumn) {\r\n    let row = result.Координаты[rowId];\r\n    if (row === undefined) {\r\n      result.Координаты[rowId] = {\r\n        Лево: startColumn,\r\n        Право: endColumn,\r\n      };\r\n    } else if (endColumn > row[\"Право\"]) {\r\n      row[\"Право\"] = endColumn;\r\n    } else {\r\n      row[\"Лево\"] = startColumn;\r\n    }\r\n  }\r\n}\r\n\r\nconst visitor = new Visitor();\r\n\n\n//# sourceURL=webpack:///./parser/visitor.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./parser/app.js");
/******/ 	
/******/ })()
;